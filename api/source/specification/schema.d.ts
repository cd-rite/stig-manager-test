/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */


/** OneOf type helpers */
type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };
type XOR<T, U> = (T | U) extends object ? (Without<T, U> & U) | (Without<U, T> & T) : T | U;
type OneOf<T extends any[]> = T extends [infer Only] ? Only : T extends [infer A, infer B, ...infer Rest] ? OneOf<[XOR<A, B>, ...Rest]> : never;

export interface paths {
  "/assets": {
    /** Return a list of Assets accessible to the requester */
    get: operations["getAssets"];
    /** Create an Asset */
    post: operations["createAsset"];
    parameters: {
      query?: {
        projection?: components["parameters"]["AssetProjectionQuery"];
      };
    };
  };
  "/assets/{assetId}": {
    /** Return an Asset */
    get: operations["getAsset"];
    /** Set all properties of an Asset */
    put: operations["replaceAsset"];
    /** Delete an Asset */
    delete: operations["deleteAsset"];
    /** Merge provided properties with an Asset */
    patch: operations["updateAsset"];
    parameters: {
      query?: {
        projection?: components["parameters"]["AssetProjectionQuery"];
      };
      path: {
        assetId: components["parameters"]["AssetIdPath"];
      };
    };
  };
  "/assets/{assetId}/checklists": {
    /** Return a multi-STIG CKL for an Asset and its mapped STIGs */
    get: operations["getChecklistByAsset"];
    parameters: {
      query?: {
        benchmarkId?: components["parameters"]["BenchmarkIdArrayQuery"];
        /** @description The format of the response. */
        format?: "ckl" | "cklb";
      };
      path: {
        assetId: components["parameters"]["AssetIdPath"];
      };
    };
  };
  "/assets/{assetId}/checklists/{benchmarkId}/{revisionStr}": {
    /** Return JSON summary, or CKL(B) file, or XCCDF file for an Asset and STIG */
    get: operations["getChecklistByAssetStig"];
    parameters: {
      path: {
        assetId: components["parameters"]["AssetIdPath"];
        benchmarkId: components["parameters"]["BenchmarkIdPath"];
        revisionStr: components["parameters"]["RevisionStrPath"];
      };
    };
  };
  "/assets/{assetId}/metadata": {
    /** Return the metadata for Asset */
    get: operations["getAssetMetadata"];
    /** Set a Asset metadata to the provided object */
    put: operations["putAssetMetadata"];
    /** Merge the provided object to a Assetmetadata */
    patch: operations["patchAssetMetadata"];
    parameters: {
      path: {
        assetId: components["parameters"]["AssetIdPath"];
      };
    };
  };
  "/assets/{assetId}/metadata/keys": {
    /** Return the keys of the provided Asset's metadata */
    get: operations["getAssetMetadataKeys"];
    parameters: {
      path: {
        assetId: components["parameters"]["AssetIdPath"];
      };
    };
  };
  "/assets/{assetId}/metadata/keys/{key}": {
    /** Return the value of the provided Asset metadata key */
    get: operations["getAssetMetadataValue"];
    /** Set the value of the provided Asset metadata key to the provided string */
    put: operations["putAssetMetadataValue"];
    /** Remove the provided Asset metadata key */
    delete: operations["deleteAssetMetadataKey"];
    parameters: {
      path: {
        assetId: components["parameters"]["AssetIdPath"];
        key: components["parameters"]["MetadataKeyPath"];
      };
    };
  };
  "/assets/{assetId}/stigs": {
    /** Return an Asset's STIG assignments */
    get: operations["getStigsByAsset"];
    /** Delete all STIG assignments to an Asset */
    delete: operations["removeStigsFromAsset"];
    parameters: {
      path: {
        assetId: components["parameters"]["AssetIdPath"];
      };
    };
  };
  "/assets/{assetId}/stigs/{benchmarkId}": {
    /** Assign a STIG to an Asset */
    put: operations["attachStigToAsset"];
    /** Delete a STIG assignment to an Asset */
    delete: operations["removeStigFromAsset"];
    parameters: {
      path: {
        assetId: components["parameters"]["AssetIdPath"];
        benchmarkId: components["parameters"]["BenchmarkIdPath"];
      };
    };
  };
  "/collections": {
    /** Return a list of Collections accessible to the requester */
    get: operations["getCollections"];
    /**
     * Create a Collection
     * @description The `settings` property is optional and can be partially provided.
     * - If `settings` is not provided, the Collection will be created with the default settings.
     * - If a partial `settings` object is provided, the Collection will be created with settings merged from the provided object and the default settings.
     *
     * The default settings are:
     * ```
     *  {
     *     fields: {
     *       detail: {
     *         enabled: 'always',
     *         required: 'always'
     *       },
     *       comment: {
     *         enabled: 'findings',
     *         required: 'findings'
     *       }
     *     },
     *     status: {
     *       canAccept: true,
     *       resetCriteria: 'result',
     *       minAcceptGrant: 3
     *     },
     *     history: {
     *       maxReviews: 15
     *     }
     *   }
     * ```
     */
    post: operations["createCollection"];
    parameters: {
      query?: {
        elevate?: components["parameters"]["ElevateQuery"];
      };
    };
  };
  "/collections/{collectionId}": {
    /** Return a Collection */
    get: operations["getCollection"];
    /**
     * Set all properties of a Collection
     * @description See the description of path `POST /collections` for notes about the `settings` property
     */
    put: operations["replaceCollection"];
    /** Delete a Collection */
    delete: operations["deleteCollection"];
    /**
     * Merge provided properties with a Collection
     * @description The `settings` property can be partially provided. If a partial `settings` object is provided, the Collection settings will be updated to the provided object merged with the **default** settings. This sets existing property values not specified in the partial object to their default values.
     *
     * The default settings are found in the description of `POST /collection`
     */
    patch: operations["updateCollection"];
    parameters: {
      query?: {
        elevate?: components["parameters"]["ElevateQuery"];
        projection?: components["parameters"]["CollectionProjectionQuery"];
      };
      path: {
        collectionId: components["parameters"]["CollectionIdPath"];
      };
    };
  };
  "/collections/{collectionId}/archive/ckl": {
    /** Return a ZIP archive containing CKL files for the supplied Assets and STIGs */
    post: operations["postCklArchiveByCollection"];
  };
  "/collections/{collectionId}/archive/cklb": {
    /** Return a ZIP archive containing CKLB files for the supplied Assets and STIGs */
    post: operations["postCklbArchiveByCollection"];
  };
  "/collections/{collectionId}/archive/xccdf": {
    /** Return a ZIP archive containing XCCDF results for the supplied Assets and STIGs */
    post: operations["postXccdfArchiveByCollection"];
  };
  "/collections/{collectionId}/checklists/{benchmarkId}/{revisionStr}": {
    /** Return the Checklist for the supplied Collection and STIG */
    get: operations["getChecklistByCollectionStig"];
    parameters: {
      path: {
        collectionId: components["parameters"]["CollectionIdPath"];
        benchmarkId: components["parameters"]["BenchmarkIdPath"];
        revisionStr: components["parameters"]["RevisionStrPath"];
      };
    };
  };
  "/collections/{collectionId}/clone": {
    /**
     * Clone an existing Collection to a new Collection
     * @description Cloning large Collections can take several minutes! Users may see a performance impact when accessing the source Collection during this time.<br><br>Making changes to the source Collection while it is being cloned may lead to inconsistent results in the cloned Collection.<br><br><b>Before proceeding, it is recommended you warn Users that they refrain from modifying components of the source Collection while the cloning process is underway.</b>
     */
    post: operations["cloneCollection"];
  };
  "/collections/{collectionId}/export-to/{dstCollectionId}": {
    /**
     * Export reviews from a source Collection to a destination Collection
     * @description Exports reviews (result, detail and comment) from a `srcCollection` to a `dstCollection`, creating Assets in `dstCollection` if they do not exist. The `status` property of existing reviews in `dstCollection` are reset, if necessary, in accordance with the Collection settings.
     */
    post: operations["exportToCollection"];
  };
  "/collections/{collectionId}/findings": {
    /** Return the Findings for the specified Collection */
    get: operations["getFindingsByCollection"];
    parameters: {
      query: {
        aggregator: components["parameters"]["FindingAggregatorQuery"];
        acceptedOnly?: boolean;
        benchmarkId?: components["parameters"]["BenchmarkIdQuery"];
        assetId?: components["parameters"]["AssetIdQuery"];
        projection?: components["parameters"]["FindingProjectionQuery"];
      };
      path: {
        collectionId: components["parameters"]["CollectionIdPath"];
      };
    };
  };
  "/collections/{collectionId}/grants/{userId}/access": {
    /** Return an accessLevel = 1 User's access to the specified Collection. Request must be made by a User with accessLevel >= 3 to the Collection. */
    get: operations["getStigAssetsByCollectionUser"];
    /** Set an accessLevel = 1 User's access to the specified Collection. Request must be made by a User with accessLevel >= 3 to the Collection. */
    put: operations["setStigAssetsByCollectionUser"];
    parameters: {
      path: {
        collectionId: components["parameters"]["CollectionIdPath"];
        userId: components["parameters"]["UserIdPath"];
      };
    };
  };
  "/collections/{collectionId}/reviews": {
    /** Return a list of Reviews accessible to the requester */
    get: operations["getReviewsByCollection"];
    /**
     * Insert, update, or merge a complete or partial Review to multiple Assets and Rules
     * @description
     * Applies a complete or partial Review to multiple target Asset/Rule pairs. Depending on the Review properties supplied, new Reviews may be created, existing Reviews may be updated, or both operations may occur (similar to an SQL merge).
     *
     * ## Caution
     *
     * **It is possible to send a request which will place the database under considerable load and take many seconds (or minutes) to complete. To determine if a request affects a large set of Reviews, clients are strongly encouraged to send a "preflight" request with the `dryRun` option enabled.**
     *
     * ## Request Validation
     *
     * The overall request is validated as follows:
     *
     * - conformance with the OAS schema for `ReviewBatch`
     * - the requesting user has been granted access to the {collectionId}
     *
     * ## Request body
     *
     * **source** *(required)*
     *
     *   The Review source is applied to the product of `assets` x `rules` (see below). It MUST contain at least one of the properties `result`, `detail`, `comment`, `resultEngine`, `metadata` or `status`.
     * - Multiple properties can be specified.
     * - a string value for the `status` property is normalized to `{ label: <string>, text: null }`
     *
     *
     * **assets** *(required)*
     *
     * The target Assets, which are specified as either:
     *   - an array of `assetId`
     *   - an array of `benchmarkId` where target Assets are calculated as the list of distinct Assets assigned at least one of the given STIGs, taking into account the requesting User's collection grant.
     *
     * **rules** *(required)*
     *
     * The target Rules, which are specified as either:
     *   - an array of `ruleId`
     *   - an array of `benchmarkId` where target Rules are calculated as the list of distinct Rules from all available revisions of the given STIGs.
     *
     * **action** *(optional)*
     *
     * Constrains the data action to be taken. If present, the value MUST be one of `insert`, `update`, or `merge`.
     *
     *   - `insert`: only create new Reviews, do not update existing Reviews
     *   - `update`: only update existing Reviews, do not create new Reviews
     *   - `merge`: create new Reviews and update existing Reviews
     *
     * If not present, the default value is:
     *
     *   - `merge` if the source Review includes `result`
     *   - `update` if the source Review does not include `result`
     *
     * New Reviews cannot be created when `source` does not include `result`. In that case, specifying either the `insert` or `merge` value is an error.
     *
     * **updateFilters** *(optional)*
     *
     * Limits the Reviews to be updated, based on an array of filtering objects. If present, updates are applied to Reviews from the product `assets` x `rules` that pass each of the filters (filters are combined with logical AND). If not present, updates are applied to each Review from the product `assets` x `rules`.
     *
     * Filtering objects specify a Review `field` , a `condition`, and a `value`. See the schema definition for further details.
     *
     * **dryRun** *(optional)*
     *
     * If present with a `true` value, performs all processing and validation logic without actually changing any data. Useful to verify what a given request would do and to reveal any validation errors. The default value is `false`.
     *
     * ## Review candidates
     *
     * Candidate Reviews are created by cross joining the source Review with the product of `assets` x `rules` and applying the resulting rows to existing Reviews (if any) in accordance with the Collection settings.
     *
     * **For updated Reviews**
     *
     * In general, an absent source Review property will retain existing values except as below.
     *
     * - an absent `status` property will either retain the existing value or update the `status` value to `{ label: "saved", text: "Review change triggered status update" }`, in accordance with the Collection `settings.status.resetCriteria`.
     * - an absent `resultEngine` property will either retain the existing value or update the `resultEngine` value to `null`. If applying the source Review changes an existing `result`, the `resultEngine` value will be set to `null`.
     *
     * **For new Reviews**
     *
     * - an absent `detail` or `comment` property will set the candidate value to the empty string.
     * - an absent `status` property will set the candidate value to `{ label: "saved", text: null }`.
     * - an absent `resultEngine` property will set the candidate value to `null`.
     * - an absent `metadata` property will set the candidate value to `{}`
     *
     * ## Candidate validation
     *
     * Each candidate Review is permitted or rejected as follows:
     *
     * - If the requesting user's collection grant is `restricted` AND the `ruleId` is not included in any version of any `benchmarkId` for which the requesting user been granted access, then **reject** the Review.
     * - If `status.label` has value `saved`, then permit the Review.
     * - If the Review would not be submittable according to the Collection settings, then **reject** the Review
     * - If the value of `status.label` is `submitted`, then **permit** the Review.
     * - If the value of `status.label` is `accepted` or `rejected` AND the Collection settings allow Reviews to be Accepted or Rejected, then **permit** the Review.
     * - If `status.label` has value `accepted` or `rejected` AND the Collection settings prohibit Reviews from being Accepted or Rejected, then **reject** the Review.
     */
    post: operations["postReviewBatch"];
  };
  "/collections/{collectionId}/reviews/{assetId}": {
    /** Return a list of Reviews for an Asset */
    get: operations["getReviewsByAsset"];
    /**
     * Post one or more Reviews
     * @description The request body is an array that can contain both new and updated Reviews. All Reviews MUST contain the properties `ruleId`, `result`, `detail`, and `comment`. The overall request is validated as follows:
     *
     * - conformance with the OAS schema for `ReviewAssetPost`
     * - the requesting user has been granted access to the {collectionId}
     *
     * **For all Reviews**
     *
     * - a string value for the `status` property will set the stored value to `{ label: <string>, text: null }`
     * - an absent `resultEngine` property will set the stored value to `null`
     *
     * **For updated Reviews**
     *
     * - a `null` value for either `detail` or `comment` will retain the existing value.
     * - an absent `status` property will either retain the existing value or update the `status` value to `{ label: "saved", text: "Review change triggered status update" }`, in accordance with the Collection `settings.status.resetCriteria`.
     *
     * **For new Reviews**
     *
     * - a `null` value for either `detail` or `comment` will set the stored value to the empty string.
     * - an absent `status` property will set the stored value to `{ label: "saved", text: null }`.
     *
     * **Each new or updated Review is permitted or rejected as follows:**
     *
     * - If the requesting user's collection grant is `restricted` AND the `ruleId` is not included in any version of any `benchmarkId` for which the requesting user been granted access, then **reject** the Review
     * - If the optional property `status` is absent or `status.label` has value `saved`, then permit the Review
     * - If the new or updated Review would not be submittable according to the Collection settings, then **reject** the Review
     * - If the value of `status.label` is `submitted`, then **permit** the Review.
     * - If the value of `status.label` is `accepted` or `rejected` AND the Collection settings allow Reviews to be Accepted or Rejected, then **permit** the Review.
     * - If `status.label` has value `accepted` or `rejected` AND the Collection settings prohibit Reviews from being Accepted or Rejected, then **reject** the Review.
     */
    post: operations["postReviewsByAsset"];
  };
  "/collections/{collectionId}/reviews/{assetId}/{ruleId}": {
    /** Return the Review for an Asset and Rule */
    get: operations["getReviewByAssetRule"];
    /**
     * Set all properties of a Review
     * @description The request can target either a new or an existing Review. The request body MUST contain the Review properties `result`, `detail`, and `comment`. The overall request is validated as follows:
     *
     * - conformance with the OAS schema for `ReviewAssetRulePut`
     * - the requesting user has been granted access to the {collectionId}
     *
     * **For all Reviews**
     *
     * - a string value for the `status` property will set the stored value to `{ label: <string>, text: null }`
     * - an absent `resultEngine` property will set the stored value to `resultEngine: null`
     *
     * **For updated Reviews**
     *
     * - a `null` value for either `detail` or `comment` will retain the existing value.
     * - an absent `status` property will either retain or update the `status` value to `{ label: "saved", text: "Review change triggered status update" }`, in accordance with the Collection `settings.status.resetCriteria`.
     *
     * **For new Reviews**
     *
     * - a `null` value for either `detail` or `comment` will set the stored value to the empty string.
     * - an absent `status` property will set the stored value to `{ label: "saved", text: null }`.
     *
     * The request is permitted or rejected as follows:
     *
     * - If the requesting user's collection grant is `restricted` AND the `assetId` is not included in any user grant, then **reject** the Review
     * - If the requesting user's collection grant is `restricted` AND the `ruleId` is not included in any version of any `benchmarkId` for which the user been granted access, then **reject** the Review
     * - If the new or updated Review would not be submittable according to the Collection settings, then **reject** the Review
     * - If the value of `status.label` is `submitted`, then **permit** the Review.
     * - If the value of `status.label` is `accepted` or `rejected` AND the Collection settings allow Reviews to be Accepted or Rejected, then **permit** the Review.
     * - If `status.label` has value `accepted` or `rejected` AND the Collection settings prohibit Reviews from being Accepted or Rejected, then **reject** the Review.
     */
    put: operations["putReviewByAssetRule"];
    /** Delete a Review */
    delete: operations["deleteReviewByAssetRule"];
    /**
     * Merge the provided properties with an existing Review
     * @description The request MUST target an existing Review and the request body MUST contain one or more Review properties. The overall request is validated as follows:
     *
     * - conformance with the OAS schema for `ReviewAssetRulePatch`
     * - the requesting user has been granted access to the {collectionId}
     * - a Review already exists for the {assetId} and {ruleId}
     *
     * A string value for the `status` property will set the stored value to `{ label: <string>, text: null }`.
     *
     * If the request changes the existing `result`, then the `resultEngine` value will be set to `null` unless the request includes an explicit `resultEngine` value.
     *
     * An absent `status` property may still lead to the `status` value being updated to `{ label: "saved", text: "Review change triggered status update" }`, in accordance with the Collection `settings.status.resetCriteria`.
     *
     * Unlike the corresponding PUT endpoint, the `detail` and `comment` properties do not support `null` as a value.
     *
     * The request is permitted or rejected as follows:
     *
     * - If the requesting user's collection grant is `restricted` AND the `assetId` is not included in any user grant, then **reject** the Review
     * - If the requesting user's collection grant is `restricted` AND the `ruleId` is not included in any version of any `benchmarkId` for which the user been granted access, then **reject** the Review
     * - If the new or updated Review would not be submittable according to the Collection settings, then **reject** the Review
     * - If the value of `status.label` is `submitted`, then **permit** the Review.
     * - If the value of `status.label` is `accepted` or `rejected` AND the Collection settings allow Reviews to be Accepted or Rejected, then **permit** the Review.
     * - If `status.label` has value `accepted` or `rejected` AND the Collection settings prohibit Reviews from being Accepted or Rejected, then **reject** the Review.
     */
    patch: operations["patchReviewByAssetRule"];
    parameters: {
      query?: {
        projection?: components["parameters"]["ReviewProjectionQuery"];
      };
      path: {
        collectionId: components["parameters"]["CollectionIdPath"];
        assetId: components["parameters"]["AssetIdPath"];
        ruleId: components["parameters"]["RuleIdPath"];
      };
    };
  };
  "/collections/{collectionId}/reviews/{assetId}/{ruleId}/metadata": {
    /** Return the metadata for Review */
    get: operations["getReviewMetadata"];
    /** Set a Review metadata to the provided object */
    put: operations["putReviewMetadata"];
    /** Merge the provided object to a Review metadata */
    patch: operations["patchReviewMetadata"];
    parameters: {
      path: {
        collectionId: components["parameters"]["CollectionIdPath"];
        assetId: components["parameters"]["AssetIdPath"];
        ruleId: components["parameters"]["RuleIdPath"];
      };
    };
  };
  "/collections/{collectionId}/reviews/{assetId}/{ruleId}/metadata/keys": {
    /** Return the keys of the provided Review's metadata */
    get: operations["getReviewMetadataKeys"];
    parameters: {
      path: {
        collectionId: components["parameters"]["CollectionIdPath"];
        assetId: components["parameters"]["AssetIdPath"];
        ruleId: components["parameters"]["RuleIdPath"];
      };
    };
  };
  "/collections/{collectionId}/reviews/{assetId}/{ruleId}/metadata/keys/{key}": {
    /** Return the value of the provided Review metadata key */
    get: operations["getReviewMetadataValue"];
    /** Set the value of the provided Review metadata key to the provided string */
    put: operations["putReviewMetadataValue"];
    /** Remove the provided Review metadata key */
    delete: operations["deleteReviewMetadataKey"];
    parameters: {
      path: {
        collectionId: components["parameters"]["CollectionIdPath"];
        assetId: components["parameters"]["AssetIdPath"];
        ruleId: components["parameters"]["RuleIdPath"];
        key: components["parameters"]["MetadataKeyPath"];
      };
    };
  };
  "/collections/{collectionId}/labels": {
    /** Return labels of the specified Collection */
    get: operations["getCollectionLabels"];
    /** Create a label in the specified Collection */
    post: operations["createCollectionLabel"];
  };
  "/collections/{collectionId}/labels/{labelId}": {
    /** Return the specified Label of the specified Collection */
    get: operations["getCollectionLabelById"];
    /** Delete a Label */
    delete: operations["deleteCollectionLabelById"];
    /** Update an existing Label */
    patch: operations["patchCollectionLabelById"];
    parameters: {
      path: {
        collectionId: components["parameters"]["CollectionIdPath"];
        labelId: components["parameters"]["LabelIdPath"];
      };
    };
  };
  "/collections/{collectionId}/labels/{labelId}/assets": {
    /** Return the Assets mapped to the Label */
    get: operations["getAssetsByCollectionLabelId"];
    /** Replace the Label's Asset mappings */
    put: operations["putAssetsByCollectionLabelId"];
    parameters: {
      path: {
        collectionId: components["parameters"]["CollectionIdPath"];
        labelId: components["parameters"]["LabelIdPath"];
      };
    };
  };
  "/collections/{collectionId}/metadata": {
    /** Return the metadata for Collection */
    get: operations["getCollectionMetadata"];
    /** Set a Collection metadata to the provided object */
    put: operations["putCollectionMetadata"];
    /** Merge the provided object to a Collection metadata */
    patch: operations["patchCollectionMetadata"];
    parameters: {
      query?: {
        elevate?: components["parameters"]["ElevateQuery"];
      };
      path: {
        collectionId: components["parameters"]["CollectionIdPath"];
      };
    };
  };
  "/collections/{collectionId}/metadata/keys": {
    /** Return the keys of the provided Collection metadata */
    get: operations["getCollectionMetadataKeys"];
    parameters: {
      query?: {
        elevate?: components["parameters"]["ElevateQuery"];
      };
      path: {
        collectionId: components["parameters"]["CollectionIdPath"];
      };
    };
  };
  "/collections/{collectionId}/metadata/keys/{key}": {
    /** Return the value of the provided Collection metadata key */
    get: operations["getCollectionMetadataValue"];
    /** Set the value of the provided Collection metadata key to the provided string */
    put: operations["putCollectionMetadataValue"];
    /** Remove the provided Collection metadata key */
    delete: operations["deleteCollectionMetadataKey"];
    parameters: {
      query?: {
        elevate?: components["parameters"]["ElevateQuery"];
      };
      path: {
        collectionId: components["parameters"]["CollectionIdPath"];
        key: components["parameters"]["MetadataKeyPath"];
      };
    };
  };
  "/collections/{collectionId}/metrics/detail": {
    /** Return unaggregated Asset/STIG metrics for the specified Collection */
    get: operations["getMetricsDetailByCollection"];
    parameters: {
      query?: {
        benchmarkId?: components["parameters"]["BenchmarkIdArrayQuery"];
        assetId?: components["parameters"]["AssetIdArrayQuery"];
        labelId?: components["parameters"]["LabelIdQuery"];
        labelName?: components["parameters"]["LabelNameQuery"];
        labelMatch?: components["parameters"]["LabelMatchQuery"];
        format?: components["parameters"]["MetricsFormatQuery"];
      };
      path: {
        collectionId: components["parameters"]["CollectionIdPath"];
      };
    };
  };
  "/collections/{collectionId}/metrics/detail/asset": {
    /** Return metrics for the specified Collection aggregated by Asset */
    get: operations["getMetricsDetailByCollectionAggAsset"];
    parameters: {
      query?: {
        benchmarkId?: components["parameters"]["BenchmarkIdArrayQuery"];
        assetId?: components["parameters"]["AssetIdArrayQuery"];
        labelId?: components["parameters"]["LabelIdQuery"];
        labelName?: components["parameters"]["LabelNameQuery"];
        labelMatch?: components["parameters"]["LabelMatchQuery"];
        format?: components["parameters"]["MetricsFormatQuery"];
      };
      path: {
        collectionId: components["parameters"]["CollectionIdPath"];
      };
    };
  };
  "/collections/{collectionId}/metrics/detail/collection": {
    /** Return aggregated metrics for the specified Collection */
    get: operations["getMetricsDetailByCollectionAgg"];
    parameters: {
      query?: {
        benchmarkId?: components["parameters"]["BenchmarkIdArrayQuery"];
        assetId?: components["parameters"]["AssetIdArrayQuery"];
        labelId?: components["parameters"]["LabelIdQuery"];
        labelName?: components["parameters"]["LabelNameQuery"];
        labelMatch?: components["parameters"]["LabelMatchQuery"];
        format?: components["parameters"]["MetricsFormatQuery"];
      };
      path: {
        collectionId: components["parameters"]["CollectionIdPath"];
      };
    };
  };
  "/collections/{collectionId}/metrics/detail/label": {
    /** Return metrics for the specified Collection aggregated by Label */
    get: operations["getMetricsDetailByCollectionAggLabel"];
    parameters: {
      query?: {
        benchmarkId?: components["parameters"]["BenchmarkIdArrayQuery"];
        assetId?: components["parameters"]["AssetIdArrayQuery"];
        labelId?: components["parameters"]["LabelIdQuery"];
        labelName?: components["parameters"]["LabelNameQuery"];
        labelMatch?: components["parameters"]["LabelMatchQuery"];
        format?: components["parameters"]["MetricsFormatQuery"];
      };
      path: {
        collectionId: components["parameters"]["CollectionIdPath"];
      };
    };
  };
  "/collections/{collectionId}/metrics/detail/stig": {
    /** Return metrics for the specified Collection aggregated by STIG */
    get: operations["getMetricsDetailByCollectionAggStig"];
    parameters: {
      query?: {
        benchmarkId?: components["parameters"]["BenchmarkIdArrayQuery"];
        assetId?: components["parameters"]["AssetIdArrayQuery"];
        labelId?: components["parameters"]["LabelIdQuery"];
        labelName?: components["parameters"]["LabelNameQuery"];
        labelMatch?: components["parameters"]["LabelMatchQuery"];
        format?: components["parameters"]["MetricsFormatQuery"];
      };
      path: {
        collectionId: components["parameters"]["CollectionIdPath"];
      };
    };
  };
  "/collections/{collectionId}/metrics/summary": {
    /** Return unaggregated Asset/STIG metrics for the specified Collection */
    get: operations["getMetricsSummaryByCollection"];
    parameters: {
      query?: {
        benchmarkId?: components["parameters"]["BenchmarkIdArrayQuery"];
        assetId?: components["parameters"]["AssetIdArrayQuery"];
        labelId?: components["parameters"]["LabelIdQuery"];
        labelName?: components["parameters"]["LabelNameQuery"];
        labelMatch?: components["parameters"]["LabelMatchQuery"];
        format?: components["parameters"]["MetricsFormatQuery"];
      };
      path: {
        collectionId: components["parameters"]["CollectionIdPath"];
      };
    };
  };
  "/collections/{collectionId}/metrics/summary/asset": {
    /** Return metrics for the specified Collection aggregated by Asset */
    get: operations["getMetricsSummaryByCollectionAggAsset"];
    parameters: {
      query?: {
        benchmarkId?: components["parameters"]["BenchmarkIdArrayQuery"];
        assetId?: components["parameters"]["AssetIdArrayQuery"];
        labelId?: components["parameters"]["LabelIdQuery"];
        labelName?: components["parameters"]["LabelNameQuery"];
        labelMatch?: components["parameters"]["LabelMatchQuery"];
        format?: components["parameters"]["MetricsFormatQuery"];
      };
      path: {
        collectionId: components["parameters"]["CollectionIdPath"];
      };
    };
  };
  "/collections/{collectionId}/metrics/summary/collection": {
    /** Return aggregated metrics for the specified Collection */
    get: operations["getMetricsSummaryByCollectionAgg"];
    parameters: {
      query?: {
        benchmarkId?: components["parameters"]["BenchmarkIdArrayQuery"];
        assetId?: components["parameters"]["AssetIdArrayQuery"];
        labelId?: components["parameters"]["LabelIdQuery"];
        labelName?: components["parameters"]["LabelNameQuery"];
        labelMatch?: components["parameters"]["LabelMatchQuery"];
        format?: components["parameters"]["MetricsFormatQuery"];
      };
      path: {
        collectionId: components["parameters"]["CollectionIdPath"];
      };
    };
  };
  "/collections/{collectionId}/metrics/summary/label": {
    /** Return metrics for the specified Collection aggregated by Label */
    get: operations["getMetricsSummaryByCollectionAggLabel"];
    parameters: {
      query?: {
        benchmarkId?: components["parameters"]["BenchmarkIdArrayQuery"];
        assetId?: components["parameters"]["AssetIdArrayQuery"];
        labelId?: components["parameters"]["LabelIdQuery"];
        labelName?: components["parameters"]["LabelNameQuery"];
        labelMatch?: components["parameters"]["LabelMatchQuery"];
        format?: components["parameters"]["MetricsFormatQuery"];
      };
      path: {
        collectionId: components["parameters"]["CollectionIdPath"];
      };
    };
  };
  "/collections/{collectionId}/metrics/summary/stig": {
    /** Return metrics for the specified Collection aggregated by STIG */
    get: operations["getMetricsSummaryByCollectionAggStig"];
    parameters: {
      query?: {
        benchmarkId?: components["parameters"]["BenchmarkIdArrayQuery"];
        assetId?: components["parameters"]["AssetIdArrayQuery"];
        labelId?: components["parameters"]["LabelIdQuery"];
        labelName?: components["parameters"]["LabelNameQuery"];
        labelMatch?: components["parameters"]["LabelMatchQuery"];
        format?: components["parameters"]["MetricsFormatQuery"];
      };
      path: {
        collectionId: components["parameters"]["CollectionIdPath"];
      };
    };
  };
  "/collections/{collectionId}/poam": {
    /** Return a POAM-like spreadsheet for the specified Collection aggregated by groupId */
    get: operations["getPoamByCollection"];
  };
  "/collections/{collectionId}/review-history": {
    /** Return history records for the specified Collection that meet the specified criteria */
    get: operations["getReviewHistoryByCollection"];
    /** Remove history records that meet specified criteria */
    delete: operations["deleteReviewHistoryByCollection"];
    parameters: {
      path: {
        collectionId: components["parameters"]["CollectionIdPath"];
      };
    };
  };
  "/collections/{collectionId}/review-history/stats": {
    /** Return history statistics for the specified Collection */
    get: operations["getReviewHistoryStatsByCollection"];
    parameters: {
      path: {
        collectionId: components["parameters"]["CollectionIdPath"];
      };
    };
  };
  "/collections/{collectionId}/status": {
    /** DEPRECATED - targeted for removal soon, please use the Metrics endpoints */
    get: operations["getStatusByCollection"];
    parameters: {
      query?: {
        benchmarkId?: components["parameters"]["BenchmarkIdArrayQuery"];
        assetId?: components["parameters"]["AssetIdArrayQuery"];
      };
      path: {
        collectionId: components["parameters"]["CollectionIdPath"];
      };
    };
  };
  "/collections/{collectionId}/stigs": {
    /** Return the STIGs mapped in the specified Collection */
    get: operations["getStigsByCollection"];
    parameters: {
      query?: {
        labelId?: components["parameters"]["LabelIdQuery"];
        labelName?: components["parameters"]["LabelNameQuery"];
        labelMatch?: components["parameters"]["LabelMatchQuery"];
        projection?: components["parameters"]["CollectionStigProjectionQuery"];
      };
      path: {
        collectionId: components["parameters"]["CollectionIdPath"];
      };
    };
  };
  "/collections/{collectionId}/stigs/{benchmarkId}": {
    /** Return the STIG mapped in the specified Collection */
    get: operations["getStigByCollection"];
    /**
     * Set the default Revision and/or the Asset list of a STIG in a Collection
     * @description Neither of the request body properties is required but at least one must be present. If the path parameter `{benchmarkId}` is not already mapped to at least one Asset in `{collectionId}`, then the `assetIds` property must be present.
     */
    post: operations["writeStigPropsByCollectionStig"];
    parameters: {
      query?: {
        projection?: components["parameters"]["CollectionStigProjectionQuery"];
      };
      path: {
        collectionId: components["parameters"]["CollectionIdPath"];
        benchmarkId: components["parameters"]["BenchmarkIdPath"];
      };
    };
  };
  "/collections/{collectionId}/stigs/{benchmarkId}/assets": {
    /** Get the Assets in a Collection attached to a STIG */
    get: operations["getAssetsByStig"];
    /** Set the Assets mapped to a STIG */
    put: operations["attachAssetsToStig"];
    parameters: {
      query?: {
        projection?: components["parameters"]["StigAssetsProjectionQuery"];
      };
      path: {
        collectionId: components["parameters"]["CollectionIdPath"];
        benchmarkId: components["parameters"]["BenchmarkIdPath"];
      };
    };
  };
  "/collections/{collectionId}/unreviewed/assets": {
    /** EXPERIMENTAL - Return the Assets in the specified Collection with unreviewed Rules */
    get: operations["getUnreviewedAssetsByCollection"];
    parameters: {
      query?: {
        assetId?: components["parameters"]["AssetIdQuery"];
        labelId?: components["parameters"]["LabelIdQuery"];
        labelName?: components["parameters"]["LabelNameQuery"];
        benchmarkId?: components["parameters"]["BenchmarkIdQuery"];
        severity?: components["parameters"]["RuleSeverityQuery"];
        projection?: components["parameters"]["UnreviewedAssetsProjectionQuery"];
      };
      path: {
        collectionId: components["parameters"]["CollectionIdPath"];
      };
    };
  };
  "/collections/{collectionId}/unreviewed/rules": {
    /** EXPERIMENTAL - Return the Rules in the specified Collection with unreviewed Assets */
    get: operations["getUnreviewedRulesByCollection"];
    parameters: {
      query?: {
        ruleId?: components["parameters"]["RuleIdQuery"];
        labelId?: components["parameters"]["LabelIdQuery"];
        labelName?: components["parameters"]["LabelNameQuery"];
        benchmarkId?: components["parameters"]["BenchmarkIdQuery"];
        severity?: components["parameters"]["RuleSeverityQuery"];
        projection?: components["parameters"]["UnreviewedRulesProjectionQuery"];
      };
      path: {
        collectionId: components["parameters"]["CollectionIdPath"];
      };
    };
  };
  "/op/appdata": {
    /** Export application data */
    get: operations["getAppData"];
    /** Import and overwrite application data */
    post: operations["replaceAppData"];
  };
  "/op/configuration": {
    /** Return API version and configuration information */
    get: operations["getConfiguration"];
  };
  "/op/definition": {
    /** Return the API definition */
    get: operations["getDefinition"];
  };
  "/op/details": {
    /** Return deployment details */
    get: operations["getDetails"];
  };
  "/stigs": {
    /** Return a list of available STIGs */
    get: operations["getSTIGs"];
    /** Import a STIG Benchmark */
    post: operations["importBenchmark"];
  };
  "/stigs/ccis/{cci}": {
    /** Return data for the specified CCI */
    get: operations["getCci"];
  };
  "/stigs/rules/{ruleId}": {
    /** Return the defintion and associated check and fix for the specified Rule */
    get: operations["getRuleByRuleId"];
  };
  "/stigs/scap-maps": {
    /** Return a list of SCAP benchmarkIds mapped to Manual benchmarkIds */
    get: operations["getScapMap"];
  };
  "/stigs/{benchmarkId}": {
    /** Return properties of the specified STIG */
    get: operations["getStigById"];
    /** Deletes a STIG (*** and all revisions ***) */
    delete: operations["deleteStigById"];
  };
  "/stigs/{benchmarkId}/revisions": {
    /** Return a list of revisions for the specified STIG */
    get: operations["getRevisionsByBenchmarkId"];
  };
  "/stigs/{benchmarkId}/revisions/{revisionStr}": {
    /** Return metadata for the specified revision of a STIG */
    get: operations["getRevisionByString"];
    /** Deletes the specified revision of a STIG */
    delete: operations["deleteRevisionByString"];
  };
  "/stigs/{benchmarkId}/revisions/{revisionStr}/ccis": {
    /** Return a list of CCIs from a STIG revision */
    get: operations["getCcisByRevision"];
  };
  "/stigs/{benchmarkId}/revisions/{revisionStr}/groups": {
    /** Return the list of groups for the specified revision of a STIG. */
    get: operations["getGroupsByRevision"];
  };
  "/stigs/{benchmarkId}/revisions/{revisionStr}/groups/{groupId}": {
    /**
     * Return the rules, checks and fixes for a Group from a specified revision of a STIG.
     * @description None
     */
    get: operations["getGroupByRevision"];
  };
  "/stigs/{benchmarkId}/revisions/{revisionStr}/rules": {
    /** Return rule data for the specified revision of a STIG. */
    get: operations["getRulesByRevision"];
  };
  "/stigs/{benchmarkId}/revisions/{revisionStr}/rules/{ruleId}": {
    /** Return rule data for the specified Rule in a revision of a STIG. */
    get: operations["getRuleByRevision"];
  };
  "/user": {
    /** Return the requester's user information */
    get: operations["getUserObject"];
  };
  "/users": {
    /** Return a list of Users accessible to the requester */
    get: operations["getUsers"];
    /** Create a User */
    post: operations["createUser"];
    parameters: {
      query?: {
        elevate?: components["parameters"]["ElevateQuery"];
        projection?: components["parameters"]["UserProjectionQuery"];
      };
    };
  };
  "/users/{userId}": {
    /** Return a User */
    get: operations["getUserByUserId"];
    /** Set all properties of a User */
    put: operations["replaceUser"];
    /** Delete a User that has never accessed the system. */
    delete: operations["deleteUser"];
    /** Merge provided properties with a User */
    patch: operations["updateUser"];
    parameters: {
      query?: {
        elevate?: components["parameters"]["ElevateQuery"];
        projection?: components["parameters"]["UserProjectionQuery"];
      };
      path: {
        userId: components["parameters"]["UserIdPath"];
      };
    };
  };
}

export type webhooks = Record<string, never>;

export interface components {
  schemas: {
    AccessLevel: number;
    ApiConfiguration: {
      /** @enum {string} */
      classification?: "NONE" | "U" | "FOUO" | "CUI" | "C" | "S" | "TS" | "SCI";
      commit?: {
        branch?: string;
        sha?: string;
        tag?: string;
        describe?: string;
      };
      version?: string;
    };
    ApiDefinition: Record<string, never> | unknown[];
    Asset: {
      assetId: string;
      name: string;
      fqdn: string | null;
      collection: components["schemas"]["CollectionBasic"];
      description: string | null;
      ip: string | null;
      labelIds?: components["schemas"]["LabelId"][];
      mac: string | null;
      noncomputing: boolean;
      metadata?: components["schemas"]["Metadata"];
    };
    AssetBasic: {
      assetId: string;
      name: string;
    };
    AssetLabels: {
      assetId: components["schemas"]["String255"];
      name: components["schemas"]["String255"];
    };
    AssetBasicProjected: {
      assetId: string;
      name: string;
      collectionId?: string;
      assetLabelIds?: components["schemas"]["LabelId"][];
      restrictedUserAccess?: components["schemas"]["UserBasic"][];
    };
    AssetCreateOrReplace: {
      name: string;
      fqdn?: string | null;
      /** @description The collectionId mapped to this Asset */
      collectionId: string;
      description: string | null;
      ip: string | null;
      labelIds?: components["schemas"]["LabelId"][];
      mac?: string | null;
      noncomputing: boolean;
      metadata: components["schemas"]["Metadata"];
      /** @description The benchmarkIds mapped to this Asset */
      stigs: string[];
    };
    AssetForCollection: {
      assetId?: string;
      name?: string;
    };
    AssetId: components["schemas"]["StringIntId"];
    AssetProjected: {
      assetId: string;
      name: string;
      fqdn: string | null;
      collection: components["schemas"]["CollectionBasic"];
      description: string | null;
      ip: string | null;
      labelIds: components["schemas"]["LabelId"][];
      mac: string | null;
      noncomputing: boolean;
      metadata?: components["schemas"]["Metadata"];
      statusStats?: {
        stigCount?: number;
        ruleCount?: number | null;
        acceptedCount?: number | null;
        rejectedCount?: number | null;
        submittedCount?: number | null;
        savedCount?: number | null;
        /** Format: date-time */
        minTs?: string | null;
        /** Format: date-time */
        maxTs?: string | null;
      };
      /** @description The benchmarkIds mapped to this Asset */
      stigs?: components["schemas"]["CollectionStig"][];
      stigGrants?: components["schemas"]["StigUserBasic"][];
    };
    AssetStigResponse: {
      benchmarkId: string;
      revisionStr: components["schemas"]["RevisionStrRaw"];
      /** Format: date */
      revisionDate: string;
      ruleCount: number;
    };
    /**
     * @description An array that specifies a list of Assets/STIG items.
     *
     * Each array item is an object that MUST include the property `assetId` and MAY include the property `stigs`.
     *
     * If the `stigs` property is absent, the default value of the property is used. The default value is an array of the default revisions of each STIG to which the requesting User
     * has been granted access on the Asset.
     *
     * If the `stigs` property is present, the value MUST be an array. Each array member is EITHER:
     * - an object that identifies both a `benchmarkId` and a specific `revisionStr`
     * - a string whose value is a `benchmarkId`. This is equivalent to specifying the object {"benchmarkId": [provided benchmarkId], "revisionStr": [default revisionStr for the provided benchmarkId]}
     */
    AssetStigSelection: {
      assetId: components["schemas"]["StringIntId"];
      stigs?: (components["schemas"]["RevisionBasic"] | components["schemas"]["String255"])[];
    };
    AssetUpdate: {
      name?: string;
      fqdn?: string | null;
      /** @description The collectionId mapped to this Asset */
      collectionId?: string;
      description?: string | null;
      ip?: string | null;
      labelIds?: components["schemas"]["LabelId"][];
      mac?: string | null;
      noncomputing?: boolean;
      metadata?: components["schemas"]["Metadata"];
      /** @description The benchmarkIds mapped to this Asset */
      stigs?: string[];
    };
    BenchmarkId: string;
    Cci: {
      cci?: string;
      status?: string;
      /** Format: date-time */
      publishdate?: string;
      contributor?: string;
      type?: string;
      definition?: string;
      emassAp?: components["schemas"]["EmassAp"];
      references?: components["schemas"]["CciReferenceItem"][];
      stigs?: components["schemas"]["RevisionBasic"][];
    };
    CciBasic: {
      cci: string;
      apAcronym: string;
      definition: string;
      control?: string | null;
    };
    CciListItem: {
      cci?: string;
      type?: string;
      references?: components["schemas"]["CciReferenceItem"][];
    };
    CciReferenceItem: {
      creator?: string;
      title?: string;
      version?: string;
      location?: string;
      indexDisa?: string;
      textRefNist?: string;
      parentControl?: string;
    };
    CciReferenceRev4: {
      indexDisa?: string;
      textRefNist?: string;
      parentControl?: string;
    };
    Check: {
      system?: string;
      content?: string;
    };
    ChecklistAssetStig: {
        assetId?: string;
        ruleId?: string;
        ruleTitle?: string;
        groupId?: string;
        groupTitle?: string;
        version?: string;
        severity?: components["schemas"]["RuleSeverity"];
        result?: components["schemas"]["ChecklistResult"];
        resultEngine?: components["schemas"]["ResultEngine"];
        autoResult?: boolean;
        status?: components["schemas"]["ChecklistStatus"];
      }[];
    /** @description The CKL format generated and read by DISA STIG VIewer */
    ChecklistCkl: {
      ASSET?: {
        ASSET_TYPE?: string;
        HOST_NAME?: string;
        HOST_IP?: string;
        HOST_MAC?: string;
        HOST_GUID?: string;
        HOST_FQDN?: string;
        TECH_AREA?: string;
        TARGET_KEY?: string;
      };
      STIGS?: {
        iSTIG?: ({
            STIG_INFO?: {
                SI_DATA?: {
                  SID_NAME?: string;
                  SID_DATA?: string;
                };
              }[];
            VULN?: ({
                STIG_DATA?: {
                    VULN_ATTRIBUTE?: string;
                    ATTRIBUTE_DATA?: string;
                  }[];
                /** @enum {string} */
                STATUS?: "Open" | "NotAFinding" | "Not_Applicable" | "Not_Reviewed";
                FINDING_DETAILS?: string;
                COMMENTS?: string;
                SEVERITY_OVERRIDE?: string;
                SEVERITY_JUSTIFICATION?: string;
              })[];
          })[];
      };
    };
    /** @description The CKLB format generated and read by DISA STIG VIewer 3 */
    ChecklistCklb: {
      target_data?: Record<string, never>;
      stigs?: Record<string, never>[];
    };
    ChecklistCollectionStig: {
      ruleId?: string;
      ruleTitle?: string;
      groupId?: string;
      groupTitle?: string;
      version?: string;
      severity?: components["schemas"]["RuleSeverity"];
      counts?: {
        results?: {
          pass?: number;
          fail?: number;
          notapplicable?: number;
          unassessed?: number;
        };
        statuses?: {
          saved?: number;
          submitted?: number;
          accepted?: number;
          rejected?: number;
        };
      };
    };
    /**
     * @description The Review result
     * @enum {string|null}
     */
    ChecklistResult: "fail" | "pass" | "notapplicable" | "notchecked" | "unknown" | "error" | "notselected" | "informational" | "fixed" | null;
    /**
     * @description The Review result
     * @enum {string|null}
     */
    ChecklistResultUnreviewed: "notchecked" | "unknown" | "error" | "notselected" | "informational" | "fixed" | null;
    /** @enum {string|null} */
    ChecklistStatus: "saved" | "submitted" | "accepted" | "rejected" | null;
    /** @description An XCCDF document with TestResult. Note: OAS 3.x cannot represent the actual XML schema */
    ChecklistXccdf: {
      [key: string]: unknown;
    };
    ClientErrorDuplicateAsset: {
      /** @enum {integer} */
      code?: 400;
      /** @enum {string} */
      message?: "Duplicate name";
      data?: components["schemas"]["Asset"];
    };
    ClientErrorDuplicateCollection: {
      /** @enum {integer} */
      code?: 400;
      /** @enum {string} */
      message?: "Duplicate name";
      data?: components["schemas"]["Collection"];
    };
    Collection: {
      collectionId: string;
      name: string;
      description: string | null;
      settings: components["schemas"]["CollectionSettings"];
      metadata: components["schemas"]["Metadata"];
      /** Format: date-time */
      created: string;
    };
    CollectionBasic: {
      collectionId?: string;
      name?: string;
    };
    CollectionCloneOptions: {
      /**
       * @description Clone the source Collection's users and their grants. Whether this option is enabled or not, the creator of the cloned Collection (ie. you) will be given an Owner grant in the clone.
       * @default true
       */
      grants?: boolean;
      /**
       * @description Clone the source Collection's available labels. You must enable this option AND the assets option for labels to be mapped to Assets in the clone.
       * @default true
       */
      labels?: boolean;
      /**
       * @description Clone the source Collection's Assets and their core properties. If this option is not enabled then the stagMappings and pinRevisions options are ignored.
       * @default true
       */
      assets?: boolean;
      /**
       * @description <b>withReviews:</b> Assets will be cloned with their current STIG assignments and ALL stored Reviews. This will include Reviews that are no longer associated with a current STIG assignment or are associated with a non-default Revision of a STIG.<br><br><b>withoutReviews:</b> Assets will be cloned with their current STIG assignments but NO stored Reviews will be cloned. All Metrics will be set to zero.<br><br> <b>none:</b> Assets will be cloned with only their core properties and no STIG assignments or Reviews. The pinRevisions option will be ignored.
       *
       * @default withReviews
       * @enum {string}
       */
      stigMappings?: "none" | "withReviews" | "withoutReviews";
      /**
       * @description <b>matchSource:</b> STIGs in the source Collection that are pinned to a specific Revision will be pinned to that Revision in the clone. STIGs that track the latest Revision (unpinned) in the source will be unpinned in the clone.<br><br><b>sourceDefaults:</b> All STIGs in the clone will be pinned to a specific Revision. STIGs that are pinned to a specific Revision in the source Collection will be pinned to that Revision in the clone. STIGs that track the latest Revision in the source will be pinned to the current latest Revision in the clone.
       *
       * @default matchSource
       * @enum {string}
       */
      pinRevisions?: "matchSource" | "sourceDefaults";
    };
    CollectionCloneRequest: {
      name: components["schemas"]["String255"];
      description: string | null;
      options?: components["schemas"]["CollectionCloneOptions"];
    };
    /** @description The response body is a stream of newline-delimited JSON (NDJSON) objects reporting the progress of the (possibly long running) cloning process. Each object conforms to this schema, but not all objects will have every property.<br/><br/>The sequence of objects starts with multiple {"stage": "collection"} objects, optionally followed by multiple {"stage": "reviews"} objects if review cloning is requested, and concludes with one {"stage": "result"} object whose "collection" property value conforms to the CollectionProjected schema for the created Collection.<br/><br/>Success is indicated when the final {"stage": "result"} message is sent. Errors that prevent cloning from completing are reported with {"status": "error"} and the "result" stage is not reported. Note that the endpoint will return HTTP status 200 immediately after the request is validated and the cloning process has started, so you should not rely on status 200 for indication of cloning success. */
    CollectionCloneResponse: {
      /** @enum {string} */
      stage?: "collection" | "reviews" | "result";
      stepCount?: number;
      step?: number;
      stepName?: string;
      message?: string;
      /** @enum {string} */
      status?: "running" | "finished" | "error";
      error?: Record<string, never>;
      stack?: string;
      collection?: components["schemas"]["CollectionProjected"];
    };
    CollectionCreateOrReplace: {
      name: string;
      description?: string | null;
      settings?: components["schemas"]["CollectionSettings"];
      metadata: components["schemas"]["Metadata"];
      grants: components["schemas"]["UserGrant"][];
      labels?: components["schemas"]["LabelCreate"][];
    };
    /** @description The response body is a stream of newline-delimited JSON (NDJSON) objects reporting the progress of the (possibly long running) export process. Each object conforms to this schema, but not all objects will have every property.<br/><br/>The sequence of objects starts with multiple {"stage": "prepare"} objects, followed by multiple {"stage": "assets"} objects, multiple {"stage": "reviews"} objects, and multiple {"stage": "metrics"} objects. The stream concludes with one {"stage": "commit"} object and then one {"stage": "result"} object whose "counts" property value conforms to the schema below.<br/><br/>Success is indicated when the final {"stage": "result"} message is sent. Errors that prevent exporting from completing are reported with {"status": "error"} and the "result" stage is not reported. Note that the endpoint will return HTTP status 200 immediately after the request is validated and the export process has started, so you should not rely on status 200 for indication of export success. */
    CollectionExportToResponse: {
      /** @enum {string} */
      stage?: "prepare" | "assets" | "reviews" | "metrics" | "result";
      stepCount?: number;
      step?: number;
      stepName?: string;
      message?: string;
      /** @enum {string} */
      status?: "running" | "error";
      error?: Record<string, never>;
      stack?: string;
      counts?: {
        assetsCreated?: number;
        stigsMapped?: number;
        reviewsInserted?: number;
        reviewsUpdated?: number;
      };
    };
    CollectionFieldEnabledAlways: {
      /** @enum {string} */
      enabled: "always";
      /** @enum {string} */
      required: "always" | "findings" | "optional";
    };
    CollectionFieldEnabledFindings: {
      /** @enum {string} */
      enabled: "findings";
      /** @enum {string} */
      required: "findings" | "optional";
    };
    /**
     * @example {
     *   "enabled": "always",
     *   "required": "findings"
     * }
     */
    CollectionFieldSetting: components["schemas"]["CollectionFieldEnabledAlways"] | components["schemas"]["CollectionFieldEnabledFindings"];
    CollectionFieldSettings: {
      detail: components["schemas"]["CollectionFieldSetting"];
      comment: components["schemas"]["CollectionFieldSetting"];
    };
    CollectionGrant: {
      collectionId: string;
      accessLevel: number;
    };
    CollectionGrantProjected: {
      collection?: {
        collectionId?: string;
        name?: string;
      };
      accessLevel?: number;
    };
    CollectionHistorySettings: {
      /** @example 5 */
      maxReviews: number;
    };
    CollectionProjected: {
      collectionId: string;
      name: string;
      description: string | null;
      settings: components["schemas"]["CollectionSettings"];
      metadata: components["schemas"]["Metadata"];
      assets?: components["schemas"]["AssetForCollection"][];
      stigs?: components["schemas"]["CollectionStig"][];
      grants?: components["schemas"]["UserGrantProjected"][];
      owners?: components["schemas"]["User"][];
      labels?: components["schemas"]["Label"][];
      statistics?: components["schemas"]["CollectionStatistics"];
    };
    CollectionsProjected: {
      collectionId: string;
      name: string;
      description: string | null;
      settings: components["schemas"]["CollectionSettings"];
      metadata: components["schemas"]["Metadata"];
      owners?: components["schemas"]["User"][];
      labels?: components["schemas"]["Label"][];
      statistics?: components["schemas"]["CollectionStatistics"];
    };
    CollectionSettings: {
      fields?: components["schemas"]["CollectionFieldSettings"];
      status?: components["schemas"]["CollectionStatusSettings"];
      history?: components["schemas"]["CollectionHistorySettings"];
    };
    CollectionStatistics: {
      created: components["schemas"]["StringDateTime"];
      assetCount: number;
      grantCount: number;
      checklistCount: number;
    };
    CollectionStatus: {
      assetId?: string;
      assetName?: string;
      assetLabelIds?: components["schemas"]["LabelId"][];
      benchmarkId?: string;
      /** Format: date-time */
      minTs?: string | null;
      /** Format: date-time */
      maxTs?: string | null;
      rules?: {
        total?: number;
      };
      findings?: {
        low?: number;
        medium?: number;
        high?: number;
      };
      result?: {
        notchecked?: components["schemas"]["CollectionStatusCount"];
        notapplicable?: components["schemas"]["CollectionStatusCount"];
        pass?: components["schemas"]["CollectionStatusCount"];
        fail?: components["schemas"]["CollectionStatusCount"];
        unknown?: components["schemas"]["CollectionStatusCount"];
        error?: components["schemas"]["CollectionStatusCount"];
        notselected?: components["schemas"]["CollectionStatusCount"];
        informational?: components["schemas"]["CollectionStatusCount"];
        fixed?: components["schemas"]["CollectionStatusCount"];
      };
      status?: {
        saved?: components["schemas"]["CollectionStatusCount"];
        submitted?: components["schemas"]["CollectionStatusCount"];
        rejected?: components["schemas"]["CollectionStatusCount"];
        accepted?: components["schemas"]["CollectionStatusCount"];
      };
    };
    CollectionStatusCount: {
      total: number;
      resultEngine: number;
    };
    CollectionStatusSettings: {
      canAccept: boolean;
      /** @example 2 */
      minAcceptGrant: number;
      /**
       * @example result
       * @enum {string}
       */
      resetCriteria: "any" | "result";
    };
    CollectionStig: {
      benchmarkId: string;
      revisionStr: components["schemas"]["RevisionStr"];
      /** Format: date */
      benchmarkDate: string | null;
      revisionPinned: boolean;
      ruleCount: number;
    };
    CollectionStigWithAssetCount: {
      benchmarkId: string;
      title?: string;
      revisionStr: components["schemas"]["RevisionStr"];
      /** Format: date */
      benchmarkDate: string | null;
      revisionPinned: boolean;
      ruleCount: number;
      assetCount: number;
      assets?: components["schemas"]["AssetForCollection"][];
    };
    CollectionStigWithIsDefault: {
      benchmarkId: string;
      revisionStr: components["schemas"]["RevisionStr"];
      /** Format: date */
      benchmarkDate: string | null;
      revisionPinned: boolean;
      ruleCount: number;
      isDefault: boolean;
    };
    CollectionUpdate: {
      name?: string;
      description?: string | null;
      settings?: components["schemas"]["CollectionSettings"];
      metadata?: components["schemas"]["Metadata"];
      grants?: {
          userId?: string;
          accessLevel?: number;
        }[];
    };
    CommentaryString: string;
    CommentaryStringNullable: string | null;
    /** Format: date */
    Date: string;
    Detail: {
      dbInfo?: components["schemas"]["DetailMySqlInfo"];
      assetStig?: components["schemas"]["DetailAssetStig"][];
    };
    DetailAssetStig: {
      collectionId?: components["schemas"]["StringIntId"];
      assetCnt?: number;
      range01to05?: number;
      range06to10?: number;
      range11to15?: number;
      range16plus?: number;
    };
    DetailMySqlInfo: {
      tables?: {
        [key: string]: components["schemas"]["DetailMySqlTableInfo"];
      };
    };
    DetailMySqlTableInfo: {
      tableName?: string;
      tableRows?: number | null;
      tableCollation?: string | null;
      avgRowLength?: number | null;
      dataLength?: number | null;
      maxDataLength?: number | null;
      indexLength?: number | null;
      autoIncrement?: number | null;
      createTime?: components["schemas"]["StringDateTimeNullable"];
      updateTime?: components["schemas"]["StringDateTimeNullable"];
    };
    EmassAp: {
      apAcronym?: string;
      implementation?: string;
      assessmentProcedure?: string;
    } | null;
    Error: {
      error?: string;
      detail?: string;
      stack?: string;
    };
    FindingProjected: {
      assetCount?: number;
      ruleId?: string;
      groupId?: string;
      cci?: string | null;
      title?: string;
      definition?: string | null;
      apAcronym?: string | null;
      severity?: components["schemas"]["RuleSeverity"];
      assets?: components["schemas"]["AssetBasic"][];
      ccis?: components["schemas"]["CciBasic"][];
      groups?: components["schemas"]["GroupProjected"][];
      rules?: components["schemas"]["RuleAbbr"][];
      stigs?: components["schemas"]["CollectionStig"][];
    };
    Fix: {
      fixref?: string;
      text?: string;
    };
    GroupProjected: {
      groupId?: string;
      title?: string;
      severity?: string;
      rules?: components["schemas"]["RuleAbbr"][];
    };
    Label: {
      labelId: components["schemas"]["LabelId"];
      name: components["schemas"]["LabelName"];
      description: components["schemas"]["String255Nullable"];
      color: components["schemas"]["StringHexColor"];
      uses: number;
    };
    LabelBasic: {
      labelId: components["schemas"]["LabelId"];
      name: components["schemas"]["LabelName"];
    };
    LabelCreate: {
      name: components["schemas"]["LabelName"];
      description: components["schemas"]["String255Nullable"];
      color: components["schemas"]["StringHexColor"];
    };
    LabelId: components["schemas"]["StringUuid"];
    LabelIdNullable: components["schemas"]["StringUuidNullable"];
    LabelName: string;
    LabelUpdate: {
      name?: components["schemas"]["LabelName"];
      description?: components["schemas"]["String255Nullable"];
      color?: components["schemas"]["StringHexColor"];
    };
    Metadata: {
      [key: string]: string;
    };
    MetadataKey: string;
    MetadataValue: string;
    MetricsUnagg: {
      assetId: string;
      name: string;
      labels: components["schemas"]["LabelBasic"][];
      benchmarkId: components["schemas"]["BenchmarkId"];
      title: components["schemas"]["String255"];
      revisionStr: components["schemas"]["RevisionStrRaw"];
      revisionPinned: boolean;
    };
    MetricsDetailUnagg: components["schemas"]["MetricsUnagg"] & components["schemas"]["MetricsDetail"];
    MetricsSummaryUnagg: components["schemas"]["MetricsUnagg"] & components["schemas"]["MetricsSummary"];
    MetricsAggAsset: {
      assetId: string;
      name: string;
      labels: components["schemas"]["LabelBasic"][];
      fqdn?: string | null;
      ip?: string | null;
      mac?: string | null;
      noncomputing?: boolean;
      benchmarkIds: components["schemas"]["BenchmarkId"][];
    };
    MetricsDetailAggAsset: components["schemas"]["MetricsAggAsset"] & components["schemas"]["MetricsDetail"];
    MetricsSummaryAggAsset: components["schemas"]["MetricsAggAsset"] & components["schemas"]["MetricsSummary"];
    MetricsAggCollection: {
      collectionId: string;
      name: string;
      checklists: number;
      assets: number;
      stigs: number;
    };
    MetricsDetailAggCollection: components["schemas"]["MetricsAggCollection"] & components["schemas"]["MetricsDetail"];
    MetricsSummaryAggCollection: components["schemas"]["MetricsAggCollection"] & components["schemas"]["MetricsSummary"];
    MetricsAggLabel: {
      labelId: components["schemas"]["LabelIdNullable"];
      name: string | null;
      assets: number;
    };
    MetricsDetailAggLabel: components["schemas"]["MetricsAggLabel"] & components["schemas"]["MetricsDetail"];
    MetricsSummaryAggLabel: components["schemas"]["MetricsAggLabel"] & components["schemas"]["MetricsSummary"];
    MetricsAggStig: {
      benchmarkId: components["schemas"]["BenchmarkId"];
      title: components["schemas"]["String255"];
      revisionStr: components["schemas"]["RevisionStrRaw"];
      revisionPinned: boolean;
      assets: number;
      ruleCount: number;
    };
    MetricsDetailAggStig: components["schemas"]["MetricsAggStig"] & components["schemas"]["MetricsDetail"];
    MetricsSummaryAggStig: components["schemas"]["MetricsAggStig"] & components["schemas"]["MetricsSummary"];
    MetricsDetail: {
      metrics: {
        assessments: number;
        assessmentsBySeverity: {
          low: number;
          medium: number;
          high: number;
        };
        assessed: number;
        minTs: components["schemas"]["StringDateTimeNullable"];
        maxTs: components["schemas"]["StringDateTimeNullable"];
        maxTouchTs: components["schemas"]["StringDateTimeNullable"];
        results: {
          notchecked: components["schemas"]["CollectionStatusCount"];
          notapplicable: components["schemas"]["CollectionStatusCount"];
          pass: components["schemas"]["CollectionStatusCount"];
          fail: components["schemas"]["CollectionStatusCount"];
          unknown: components["schemas"]["CollectionStatusCount"];
          error: components["schemas"]["CollectionStatusCount"];
          notselected: components["schemas"]["CollectionStatusCount"];
          informational: components["schemas"]["CollectionStatusCount"];
          fixed: components["schemas"]["CollectionStatusCount"];
        };
        statuses: {
          saved?: components["schemas"]["CollectionStatusCount"];
          submitted?: components["schemas"]["CollectionStatusCount"];
          rejected?: components["schemas"]["CollectionStatusCount"];
          accepted?: components["schemas"]["CollectionStatusCount"];
        };
        findings: {
          low: number;
          medium: number;
          high: number;
        };
      };
    };
    MetricsSummary: {
      metrics: {
        assessments: number;
        assessed: number;
        minTs: components["schemas"]["StringDateTimeNullable"];
        maxTs: components["schemas"]["StringDateTimeNullable"];
        maxTouchTs: components["schemas"]["StringDateTimeNullable"];
        results: {
          pass: number;
          fail: number;
          notapplicable: number;
          unassessed: number;
        };
        statuses: {
          saved: number;
          submitted: number;
          accepted: number;
          rejected: number;
        };
        findings: {
          low: number;
          medium: number;
          high: number;
        };
      };
    };
    ResultEngine: {
      type: components["schemas"]["ResultEngineType"];
      product: components["schemas"]["String255"];
      version?: components["schemas"]["String255"];
      time?: components["schemas"]["StringDateTime"];
      checkContent?: components["schemas"]["ResultEngineCheckContent"];
      overrides?: components["schemas"]["ResultEngineOverride"][];
    } | null;
    ResultEngineCheckContent: {
      location: components["schemas"]["String255"];
      component?: components["schemas"]["String255"];
    } | null;
    ResultEngineOverride: {
      authority: components["schemas"]["String255"];
      oldResult: components["schemas"]["ReviewResult"];
      newResult: components["schemas"]["ReviewResult"];
      remark?: components["schemas"]["String255"];
      time?: components["schemas"]["StringDateTime"];
    };
    /** @enum {string} */
    ResultEngineType: "scap" | "script" | "other";
    ReviewAsset: {
      ruleId: components["schemas"]["String255"];
      ruleIds: components["schemas"]["String255"][];
      result: components["schemas"]["ReviewResult"];
      resultEngine?: components["schemas"]["ResultEngine"];
      detail: components["schemas"]["CommentaryString"];
      comment: components["schemas"]["CommentaryString"];
      autoResult?: boolean;
      status: components["schemas"]["ReviewStatusRead"];
      userId: components["schemas"]["StringIntId"];
      username: components["schemas"]["String255"];
      ts: components["schemas"]["StringDateTime"];
      touchTs: components["schemas"]["StringDateTime"];
      metadata?: components["schemas"]["Metadata"];
      history?: components["schemas"]["ReviewHistory"][];
      stigs?: components["schemas"]["CollectionStigWithIsDefault"][];
      rule?: components["schemas"]["RuleAbbr"];
    };
    ReviewAssetRulePatch: {
      result?: components["schemas"]["ReviewResult"];
      detail?: components["schemas"]["CommentaryString"];
      comment?: components["schemas"]["CommentaryString"];
      resultEngine?: components["schemas"]["ResultEngine"];
      metadata?: components["schemas"]["Metadata"];
      status?: components["schemas"]["ReviewStatusWrite"];
    };
    ReviewAssetPost: {
      ruleId: components["schemas"]["String255"];
      result: components["schemas"]["ReviewResult"];
      resultEngine?: components["schemas"]["ResultEngine"];
      detail: components["schemas"]["CommentaryStringNullable"];
      comment: components["schemas"]["CommentaryStringNullable"];
      autoResult?: boolean;
      metadata?: components["schemas"]["Metadata"];
      status?: components["schemas"]["ReviewStatusWrite"];
    };
    ReviewAssetRulePut: {
      result: components["schemas"]["ReviewResult"];
      resultEngine?: components["schemas"]["ResultEngine"];
      detail: components["schemas"]["CommentaryStringNullable"];
      comment: components["schemas"]["CommentaryStringNullable"];
      autoResult?: boolean;
      metadata?: components["schemas"]["Metadata"];
      status?: components["schemas"]["ReviewStatusWrite"];
    };
    ReviewAssetRuleRead: {
      result: components["schemas"]["ReviewResult"];
      resultEngine?: components["schemas"]["ResultEngine"];
      detail: components["schemas"]["CommentaryString"];
      comment: components["schemas"]["CommentaryString"];
      autoResult?: boolean;
      userId: components["schemas"]["StringIntId"];
      username: components["schemas"]["String255"];
      ts: components["schemas"]["StringDateTime"];
      touchTs: components["schemas"]["StringDateTime"];
      metadata?: components["schemas"]["Metadata"];
      status: components["schemas"]["ReviewStatusRead"];
      history?: components["schemas"]["ReviewHistory"][];
      stigs?: components["schemas"]["CollectionStigWithIsDefault"][];
      rule?: components["schemas"]["RuleAbbr"];
    };
    ReviewAssetWrite: {
      ruleId: components["schemas"]["String255"];
      result: components["schemas"]["ReviewResult"];
      detail: components["schemas"]["StringMaxNullable"];
      comment: components["schemas"]["StringMaxNullable"];
      autoResult: boolean;
      metadata?: components["schemas"]["Metadata"];
      status?: components["schemas"]["ReviewStatusRestrictedWrite"];
    };
    ReviewBatch: {
      source: components["schemas"]["ReviewBatchSource"];
      assets: components["schemas"]["ReviewBatchAssetsCriteria"];
      rules: components["schemas"]["ReviewBatchRulesCriteria"];
      action?: components["schemas"]["ReviewBatchAction"];
      updateFilters?: components["schemas"]["ReviewBatchFilter"][];
      /** @default false */
      dryRun?: boolean;
    };
    /** @enum {string} */
    ReviewBatchAction: "insert" | "update" | "merge";
    ReviewBatchAssetsCriteria: components["schemas"]["ReviewBatchCriteria_AssetIds"] | components["schemas"]["ReviewBatchCriteria_BenchmarkIds"];
    ReviewBatchRulesCriteria: components["schemas"]["ReviewBatchCriteria_RuleIds"] | components["schemas"]["ReviewBatchCriteria_BenchmarkIds"];
    ReviewBatchCriteria_AssetIds: {
      assetIds: components["schemas"]["AssetId"][];
    };
    ReviewBatchCriteria_BenchmarkIds: {
      benchmarkIds: components["schemas"]["BenchmarkId"][];
    };
    ReviewBatchCriteria_RuleIds: {
      ruleIds: components["schemas"]["String255"][];
    };
    ReviewBatchFilter: components["schemas"]["ReviewBatchFilter_String"] | components["schemas"]["ReviewBatchFilter_Result"] | components["schemas"]["ReviewBatchFilter_Status"] | components["schemas"]["ReviewBatchFilter_Date"] | components["schemas"]["ReviewBatchFilter_User"];
    ReviewBatchFilter_String: {
      /** @enum {string} */
      field: "detail" | "comment" | "statusText";
      /**
       * @default equals
       * @enum {string}
       */
      condition?: "equals" | "contains" | "beginsWith" | "endsWith";
      value: string;
    };
    ReviewBatchFilter_Date: {
      /** @enum {string} */
      field: "ts" | "statusTs" | "touchTs";
      /**
       * @default equals
       * @enum {string}
       */
      condition?: "equals" | "lessThan" | "greaterThan";
      value: components["schemas"]["StringDateTime"];
    };
    ReviewBatchFilter_Result: {
      /** @enum {string} */
      field: "result";
      /**
       * @default equals
       * @enum {string}
       */
      condition?: "equals" | "notequal";
      value: components["schemas"]["ReviewResult"];
    };
    ReviewBatchFilter_Status: {
      /** @enum {string} */
      field: "statusLabel" | "status";
      /**
       * @default equals
       * @enum {string}
       */
      condition?: "equals" | "notequal";
      value: components["schemas"]["ReviewStatusLabel"];
    };
    ReviewBatchFilter_User: {
      /** @enum {string} */
      field: "userId" | "statusUserId";
      /**
       * @default equals
       * @enum {string}
       */
      condition?: "equals" | "notequal";
      value: components["schemas"]["StringIntId"];
    };
    ReviewBatchSource: {
      review: components["schemas"]["ReviewAssetRulePatch"];
    };
    ReviewBatchResponseDryRun: {
      willInsert: number;
      willUpdate: number;
      willFailValidation: number;
      validationErrors: {
          assetId?: components["schemas"]["AssetId"];
          ruleId?: components["schemas"]["String255"];
          error?: components["schemas"]["String255"];
        }[];
    };
    ReviewBatchResponse: {
      inserted: number;
      updated: number;
      failedValidation: number;
      validationErrors: {
          assetId?: components["schemas"]["AssetId"];
          ruleId?: components["schemas"]["String255"];
          error?: components["schemas"]["String255"];
        }[];
    };
    ReviewHistory: {
      result: components["schemas"]["ReviewResult"];
      resultEngine?: components["schemas"]["ResultEngine"];
      detail: components["schemas"]["CommentaryString"];
      comment: components["schemas"]["CommentaryString"];
      autoResult?: boolean;
      status: components["schemas"]["ReviewStatusRead"];
      userId: components["schemas"]["StringIntId"];
      username: components["schemas"]["String255"];
      ts: components["schemas"]["StringDateTime"];
      touchTs: components["schemas"]["StringDateTime"];
      ruleId: components["schemas"]["String255"];
    };
    ReviewHistoryAsset: {
      assetId: components["schemas"]["String255"];
      reviewHistories: components["schemas"]["ReviewHistoryRule"][];
    };
    ReviewHistoryRule: {
      ruleId: components["schemas"]["String255"];
      history: components["schemas"]["ReviewHistory"][];
    };
    ReviewHistoryDeleted: {
      HistoryEntriesDeleted: number;
    };
    ReviewHistoryStats: {
      collectionHistoryEntryCount: number;
      oldestHistoryEntryDate: components["schemas"]["StringDateTime"];
      assetHistoryEntryCounts?: components["schemas"]["ReviewHistoryStatsAsset"][];
    };
    ReviewHistoryStatsAsset: {
      assetId: components["schemas"]["String255"];
      historyEntryCount: number;
      oldestHistoryEntry: string | null;
    };
    /** @enum {string} */
    ReviewResult: "fail" | "pass" | "notapplicable" | "notchecked" | "unknown" | "error" | "notselected" | "informational" | "fixed";
    /** @enum {string} */
    ReviewStatusLabel: "saved" | "submitted" | "accepted" | "rejected";
    /** @enum {string} */
    ReviewStatusLabelRestricted: "saved" | "submitted";
    ReviewStatusWrite: OneOf<[components["schemas"]["ReviewStatusLabel"], {
      label: components["schemas"]["ReviewStatusLabel"];
      text: components["schemas"]["String255Nullable"];
    }]>;
    ReviewStatusRestrictedWrite: OneOf<[components["schemas"]["ReviewStatusLabelRestricted"], {
      label: components["schemas"]["ReviewStatusLabelRestricted"];
      text: components["schemas"]["String255Nullable"];
    }]>;
    ReviewStatusRead: {
      label: components["schemas"]["ReviewStatusLabel"];
      text: components["schemas"]["String255Nullable"];
      user: components["schemas"]["UserBasic"];
      ts: components["schemas"]["StringDateTime"];
    };
    ReviewPostResponse: {
      rejected: {
          ruleId?: components["schemas"]["String255"];
          reason?: components["schemas"]["String255"];
        }[];
      affected: {
        updated?: number;
        inserted?: number;
      };
    };
    ReviewRead: {
      assetId: components["schemas"]["StringIntId"];
      assetName: components["schemas"]["String255"];
      assetLabelIds?: components["schemas"]["LabelId"][];
      ruleId: components["schemas"]["String255"];
      ruleIds: components["schemas"]["String255"][];
      result: components["schemas"]["ReviewResult"];
      resultEngine?: components["schemas"]["ResultEngine"];
      detail: components["schemas"]["StringMaxNullable"];
      comment: components["schemas"]["StringMaxNullable"];
      autoResult?: boolean;
      userId: components["schemas"]["StringIntId"];
      username: components["schemas"]["String255"];
      ts: components["schemas"]["StringDateTime"];
      touchTs: components["schemas"]["StringDateTime"];
      metadata?: components["schemas"]["Metadata"];
      status: components["schemas"]["ReviewStatusRead"];
      stigs?: components["schemas"]["CollectionStigWithIsDefault"][];
      rule?: components["schemas"]["RuleAbbr"];
    };
    Revision: {
      benchmarkId: string;
      revisionStr: string;
      version: string;
      release: string;
      /** Format: date */
      benchmarkDate: string | null;
      status: string | null;
      /** Format: date */
      statusDate: string;
      ruleCount: number;
      collectionIds: string[];
    };
    RevisionBasic: {
      benchmarkId: components["schemas"]["String255"];
      revisionStr: components["schemas"]["RevisionStr"];
    };
    RevisionPost: {
      benchmarkId: components["schemas"]["String255"];
      revisionStr: components["schemas"]["RevisionStr"];
      /** @enum {string} */
      action: "inserted" | "preserved" | "replaced";
    };
    RevisionStr: string;
    RevisionStrRaw: string;
    RuleAbbr: {
      ruleId: string;
      version: string;
      title: string;
      severity: string;
    };
    RuleProjected: {
      ruleId: string;
      version: string;
      title: string;
      severity: string;
      groupId: string;
      groupTitle: string;
      detail?: {
        weight?: string | null;
        vulnDiscussion?: string | null;
        falsePositives?: string | null;
        falseNegatives?: string | null;
        documentable?: string | null;
        mitigations?: string | null;
        severityOverrideGuidance?: string | null;
        potentialImpacts?: string | null;
        thirdPartyTools?: string | null;
        mitigationControl?: string | null;
        responsibility?: string | null;
      };
      ccis?: components["schemas"]["CciBasic"][];
      check?: components["schemas"]["Check"];
      fix?: components["schemas"]["Fix"];
    };
    /** @enum {string} */
    RuleSeverity: "high" | "medium" | "low";
    SCAPMap: {
      scapBenchmarkId?: string;
      benchmarkId?: string;
    };
    STIG: {
      benchmarkId: string;
      title: string;
      status?: string | null;
      lastRevisionStr: string;
      /** Format: date */
      lastRevisionDate: string | null;
      ruleCount: number;
      collectionIds: string[];
      revisionStrs?: components["schemas"]["RevisionStrRaw"][];
      revisions?: components["schemas"]["Revision"][];
    };
    StigAssetPut: {
      benchmarkId: string;
      assetId: string;
    };
    StigAssetBasic: {
      benchmarkId: string;
      asset: components["schemas"]["AssetBasic"];
    };
    StigUserBasic: {
      benchmarkId: string;
      users: components["schemas"]["UserBasic"][];
    };
    String255: string;
    String255Nullable: string | null;
    /** Format: date-time */
    StringDateTime: string;
    /** Format: date-time */
    StringDateTimeNullable: string | null;
    /** @example aa33cc */
    StringHexColor: string;
    StringIntId: string;
    readonly StringIntIdReadOnly: string;
    StringIntIdNullable: string | null;
    StringMax: string;
    StringMaxNullable: string | null;
    StringUuid: string;
    readonly StringUuidReadOnly: string;
    StringUuidNullable: string | null;
    UnreviewedAsset: {
      assetId: components["schemas"]["StringIntId"];
      name: components["schemas"]["String255"];
      labels: components["schemas"]["LabelBasic"][];
      unreviewed: components["schemas"]["UnreviewedAssetItem"][];
    };
    UnreviewedAssetItem: {
      result: components["schemas"]["ChecklistResultUnreviewed"];
      ruleId: components["schemas"]["String255"];
      ruleTitle?: components["schemas"]["StringMax"];
      groupId: components["schemas"]["String255"];
      groupTitle?: components["schemas"]["StringMax"];
      severity?: components["schemas"]["RuleSeverity"];
      benchmarkId: components["schemas"]["String255"];
    };
    UnreviewedRule: {
      ruleId: components["schemas"]["String255"];
      ruleTitle?: components["schemas"]["StringMax"];
      groupId: components["schemas"]["String255"];
      groupTitle?: components["schemas"]["StringMax"];
      severity?: components["schemas"]["RuleSeverity"];
      benchmarkId: components["schemas"]["String255"];
      unreviewed: components["schemas"]["UnreviewedRuleItem"][];
    };
    UnreviewedRuleItem: {
      result: components["schemas"]["ChecklistResultUnreviewed"];
      assetId: components["schemas"]["StringIntId"];
      name: components["schemas"]["String255"];
      labels: components["schemas"]["LabelBasic"][];
    };
    User: {
      userId: string;
      username: string;
      displayName: string | null;
      email: string | null;
    };
    UserProjected: {
      userId: string;
      username: string;
      displayName: string | null;
      email: string | null;
      privileges?: components["schemas"]["UserPrivileges"];
      collectionGrants?: components["schemas"]["CollectionGrantProjected"][];
      statistics?: components["schemas"]["UserStatistics"];
    };
    UserBasic: {
      userId: string;
      username: string;
    };
    UserCreateOrReplace: {
      username: string;
      collectionGrants: components["schemas"]["CollectionGrant"][];
    };
    UserGrant: {
      userId: string;
      accessLevel: number;
    };
    UserGrantProjected: {
      user: {
        userId: string;
        username: string;
      };
      accessLevel: number;
    };
    UserPrivileges: {
      canCreateCollection?: boolean;
      canAdmin?: boolean;
    };
    UserStatistics: {
      /** Format: date-time */
      created: string;
      collectionGrantCount: number;
      lastAccess: number | null;
      lastClaims: Record<string, never>;
    };
    UserUpdate: {
      username?: string;
      collectionGrants?: components["schemas"]["CollectionGrant"][];
    };
  };
  responses: {
    /** @description The requesting User does not have access rights to the content */
    Forbidden: {
      content: {
        "application/json": components["schemas"]["Error"];
      };
    };
  };
  parameters: {
    /** @description A query parameter that identifies an Asset */
    AssetIdArrayQuery?: string[];
    /** @description A path parameter that identifies an Asset */
    AssetIdPath: string;
    /** @description A query parameter that identifies an Asset */
    AssetIdQuery?: string;
    /** @description Additional properties to include in the response. */
    AssetProjectionQuery?: ("statusStats" | "stigs" | "stigGrants")[];
    /** @description A query parameter that identifies a STIG */
    BenchmarkIdArrayQuery?: string[];
    /** @description A path parameter that identifies a STIG */
    BenchmarkIdPath: string;
    /** @description A query parameter that identifies a STIG */
    BenchmarkIdQuery?: string;
    /** @description A path parameter that identifies a CCI */
    CciPath: string;
    /** @description Additional properties to include in the response. */
    CciProjectionQuery?: ("emassAp" | "stigs" | "references")[];
    /** @description A query parameter that identifies a CCI */
    CciQuery?: string;
    /** @description Optional properties to return. Selecting "check" or "fix" will also select "fullrules" */
    ChecklistProjectionQuery?: ("cci" | "fullrules" | "check" | "fix")[];
    /** @description A query parameter that describes the CKL mode */
    CklModeQuery?: "multi" | "mono";
    /** @description A path parameter that identifies a Collection */
    CollectionIdPath: components["schemas"]["StringIntId"];
    /** @description A query parameter that identifies a Collection */
    CollectionIdQuery: string;
    /** @description A query parameter that identifies a Collection */
    CollectionIdArrayQuery?: string[];
    /** @description Additional properties to include in the response. */
    CollectionProjectionQuery?: ("assets" | "grants" | "owners" | "statistics" | "stigs" | "labels")[];
    /** @description Additional properties to include in the response. */
    CollectionsProjectionQuery?: ("owners" | "statistics" | "labels")[];
    /** @description Additional properties to include in the response. */
    CollectionStigProjectionQuery?: "assets"[];
    /** @description A path parameter that identifies a Collection */
    DstCollectionIdPath: components["schemas"]["StringIntId"];
    /** @description History entries with a timestamp after the specified end date. */
    EndDateQuery?: components["schemas"]["Date"];
    /** @description Elevate the user context for this request if user is permitted (canAdmin) */
    ElevateQuery?: boolean;
    /** @description Aggregate the findings on this property */
    FindingAggregatorQuery: "ruleId" | "groupId" | "cci";
    /** @description Optional properties to return */
    FindingProjectionQuery?: ("assets" | "groups" | "rules" | "stigs" | "ccis")[];
    /** @description Force an action, such as a delete, that would otherwise not be permitted */
    ForceQuery?: boolean;
    /** @description A path parameter that identifies a Group */
    GroupIdPath: string;
    /** @description A query parameter that identifies a Group */
    GroupIdQuery?: string;
    /** @description Additional properties to include in the response. */
    GroupProjectionQuery?: "rules"[];
    /** @description A JSONPath expression */
    JsonPathQuery?: string;
    /** @description A path parameter that specifies a Label */
    LabelIdPath: components["schemas"]["LabelId"];
    /** @description Selects Assets by labelId */
    LabelIdQuery?: components["schemas"]["LabelId"][];
    /** @description Selects Assets without labels */
    LabelMatchQuery?: "null";
    /** @description Selects Assets by label name */
    LabelNameQuery?: components["schemas"]["LabelName"][];
    /** @description A path parameter that specifies a metadata key */
    MetadataKeyPath: string;
    /** @description A query parameter that specifies metadata key:value pairs to select matching Objects */
    MetadataQuery?: string[];
    /** @description The format of the response body */
    MetricsFormatQuery?: "json" | "csv";
    /** @description Matches against the name according to the `name-match` parameter */
    NameQuery?: string;
    /** @description How to match against the `name` parameter */
    NameMatchQuery?: "exact" | "startsWith" | "endsWith" | "contains";
    /** @description Aggregate the findings on this property */
    PoamAggregatorQuery: "ruleId" | "groupId";
    /** @description Delete history entries with a timestamp earlier than the specified retention date. */
    RetentionDateQuery: components["schemas"]["Date"];
    /** @description Additional properties to include in the response. */
    ReviewProjectionQuery?: ("metadata" | "rule" | "stigs" | "history")[];
    /** @description Return review history statistics with the specified level of granularity. */
    ReviewHistoryStatsProjectionQuery?: "asset"[];
    /** @description Additional properties to include in the response. */
    ReviewsProjectionQuery?: ("metadata" | "rule" | "stigs")[];
    ReviewResultQuery?: components["schemas"]["ReviewResult"];
    ReviewRulesQuery?: "all" | "default" | "default-mapped" | "not-default" | "not-default-mapped";
    ReviewStatusQuery?: components["schemas"]["ReviewStatusLabel"];
    /** @description A path parameter that identifies a STIG revision [V{version_num}R{release_num} | 'latest' ] */
    RevisionStrPath: string;
    /** @description Selects Reviews mapped to a Revision [ V{version_num}R{release_num} |'latest' ]; requires benchmarkId */
    RevisionStrQuery?: string;
    /** @description A path parameter that identifies a Rule */
    RuleIdPath: string;
    /** @description Selects Reviews of a Rule */
    RuleIdQuery?: string;
    /** @description Additional properties to include in the response. */
    RuleProjectionQuery?: ("detail" | "ccis" | "check" | "fix")[];
    /** @description Selects Rules with the specified severity */
    RuleSeverityQuery?: components["schemas"]["RuleSeverity"][];
    /** @description History entries with a timestamp before the specified start date. */
    StartDateQuery?: components["schemas"]["Date"];
    /** @description Additional properties to include in the response. */
    StigProjectionQuery?: "revisions"[];
    /** @description Additional properties to include in the response. */
    StigAssetsProjectionQuery?: "restrictedUserAccess"[];
    /** @description Additional properties to include in the `unreviewed` objects. */
    UnreviewedAssetsProjectionQuery?: ("ruleTitle" | "groupTitle")[];
    /** @description Additional properties to include in the response. */
    UnreviewedRulesProjectionQuery?: ("ruleTitle" | "groupTitle")[];
    UserAccessLevelQuery?: components["schemas"]["AccessLevel"];
    /** @description A path parameter that identifies a User */
    UserIdPath: string;
    /** @description A path parameter that identifies a User */
    UserIdQuery?: string;
    /** @description Matches against the username according to the `username-match` parameter */
    UsernameQuery?: string;
    /** @description How to match against the `username` parameter */
    UsernameMatchQuery?: "exact" | "startsWith" | "endsWith" | "contains";
    /** @description Additional properties to include in the response. */
    UserProjectionQuery?: ("collectionGrants" | "statistics")[];
  };
  requestBodies: never;
  headers: never;
  pathItems: never;
}

export type $defs = Record<string, never>;

export type external = Record<string, never>;

export interface operations {

  /** Return a list of Assets accessible to the requester */
  getAssets: {
    parameters: {
      query: {
        projection?: components["parameters"]["AssetProjectionQuery"];
        collectionId: components["parameters"]["CollectionIdQuery"];
        labelId?: components["parameters"]["LabelIdQuery"];
        labelName?: components["parameters"]["LabelNameQuery"];
        labelMatch?: components["parameters"]["LabelMatchQuery"];
        name?: components["parameters"]["NameQuery"];
        "name-match"?: components["parameters"]["NameMatchQuery"];
        metadata?: components["parameters"]["MetadataQuery"];
        benchmarkId?: components["parameters"]["BenchmarkIdQuery"];
      };
    };
    responses: {
      /** @description AssetProjected array response */
      200: {
        content: {
          "application/json": components["schemas"]["AssetProjected"][];
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** Create an Asset */
  createAsset: {
    parameters: {
      query?: {
        projection?: components["parameters"]["AssetProjectionQuery"];
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["AssetCreateOrReplace"];
      };
    };
    responses: {
      /** @description AssetProjected response */
      201: {
        content: {
          "application/json": components["schemas"]["AssetProjected"];
        };
      };
      /** @description Client Error */
      400: {
        content: {
          "application/json": components["schemas"]["ClientErrorDuplicateAsset"];
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** Return an Asset */
  getAsset: {
    parameters: {
      query?: {
        projection?: components["parameters"]["AssetProjectionQuery"];
      };
      path: {
        assetId: components["parameters"]["AssetIdPath"];
      };
    };
    responses: {
      /** @description AssetProjected response */
      200: {
        content: {
          "application/json": components["schemas"]["AssetProjected"];
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** Set all properties of an Asset */
  replaceAsset: {
    parameters: {
      query?: {
        projection?: components["parameters"]["AssetProjectionQuery"];
      };
      path: {
        assetId: components["parameters"]["AssetIdPath"];
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["AssetCreateOrReplace"];
      };
    };
    responses: {
      /** @description AssetProjected response */
      200: {
        content: {
          "application/json": components["schemas"]["AssetProjected"];
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** Delete an Asset */
  deleteAsset: {
    parameters: {
      query?: {
        projection?: components["parameters"]["AssetProjectionQuery"];
      };
      path: {
        assetId: components["parameters"]["AssetIdPath"];
      };
    };
    responses: {
      /** @description AssetProjected response */
      200: {
        content: {
          "application/json": components["schemas"]["AssetProjected"];
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** Merge provided properties with an Asset */
  updateAsset: {
    parameters: {
      query?: {
        projection?: components["parameters"]["AssetProjectionQuery"];
      };
      path: {
        assetId: components["parameters"]["AssetIdPath"];
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["AssetUpdate"];
      };
    };
    responses: {
      /** @description AssetProjected response */
      200: {
        content: {
          "application/json": components["schemas"]["AssetProjected"];
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** Return a multi-STIG CKL for an Asset and its mapped STIGs */
  getChecklistByAsset: {
    parameters: {
      query?: {
        benchmarkId?: components["parameters"]["BenchmarkIdArrayQuery"];
        /** @description The format of the response. */
        format?: "ckl" | "cklb";
      };
      path: {
        assetId: components["parameters"]["AssetIdPath"];
      };
    };
    responses: {
      /** @description Review response */
      200: {
        content: {
          "application/xml": components["schemas"]["ChecklistCkl"];
          "application/json": components["schemas"]["ChecklistCklb"];
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** Return JSON summary, or CKL(B) file, or XCCDF file for an Asset and STIG */
  getChecklistByAssetStig: {
    parameters: {
      query?: {
        /** @description The format of the response. */
        format?: "json" | "ckl" | "cklb" | "xccdf";
      };
      path: {
        assetId: components["parameters"]["AssetIdPath"];
        benchmarkId: components["parameters"]["BenchmarkIdPath"];
        revisionStr: components["parameters"]["RevisionStrPath"];
      };
    };
    responses: {
      /** @description A JSON array of Checklist summary items or a CKL */
      200: {
        content: {
          "application/json": components["schemas"]["ChecklistAssetStig"] | components["schemas"]["ChecklistCklb"];
          "application/xml": components["schemas"]["ChecklistCkl"] | components["schemas"]["ChecklistXccdf"];
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** Return the metadata for Asset */
  getAssetMetadata: {
    parameters: {
      path: {
        assetId: components["parameters"]["AssetIdPath"];
      };
    };
    responses: {
      /** @description Metadata response */
      200: {
        content: {
          "application/json": components["schemas"]["Metadata"];
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** Set a Asset metadata to the provided object */
  putAssetMetadata: {
    parameters: {
      path: {
        assetId: components["parameters"]["AssetIdPath"];
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["Metadata"];
      };
    };
    responses: {
      /** @description Metadata response */
      200: {
        content: {
          "application/json": components["schemas"]["Metadata"];
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** Merge the provided object to a Assetmetadata */
  patchAssetMetadata: {
    parameters: {
      path: {
        assetId: components["parameters"]["AssetIdPath"];
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["Metadata"];
      };
    };
    responses: {
      /** @description Metadata response */
      200: {
        content: {
          "application/json": components["schemas"]["Metadata"];
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** Return the keys of the provided Asset's metadata */
  getAssetMetadataKeys: {
    parameters: {
      path: {
        assetId: components["parameters"]["AssetIdPath"];
      };
    };
    responses: {
      /** @description MetadataKeys response */
      200: {
        content: {
          "application/json": components["schemas"]["MetadataKey"][];
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** Return the value of the provided Asset metadata key */
  getAssetMetadataValue: {
    parameters: {
      path: {
        assetId: components["parameters"]["AssetIdPath"];
        key: components["parameters"]["MetadataKeyPath"];
      };
    };
    responses: {
      /** @description MetadataValue response */
      200: {
        content: {
          "application/json": components["schemas"]["MetadataValue"];
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** Set the value of the provided Asset metadata key to the provided string */
  putAssetMetadataValue: {
    parameters: {
      path: {
        assetId: components["parameters"]["AssetIdPath"];
        key: components["parameters"]["MetadataKeyPath"];
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["MetadataValue"];
      };
    };
    responses: {
      /** @description Empty to avoid large response after putting key with large value */
      204: {
        content: never;
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** Remove the provided Asset metadata key */
  deleteAssetMetadataKey: {
    parameters: {
      path: {
        assetId: components["parameters"]["AssetIdPath"];
        key: components["parameters"]["MetadataKeyPath"];
      };
    };
    responses: {
      /** @description Empty to avoid large response after deleting key with large value */
      204: {
        content: never;
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** Return an Asset's STIG assignments */
  getStigsByAsset: {
    parameters: {
      path: {
        assetId: components["parameters"]["AssetIdPath"];
      };
    };
    responses: {
      /** @description STIG array response */
      200: {
        content: {
          "application/json": components["schemas"]["AssetStigResponse"][];
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** Delete all STIG assignments to an Asset */
  removeStigsFromAsset: {
    parameters: {
      path: {
        assetId: components["parameters"]["AssetIdPath"];
      };
    };
    responses: {
      /** @description STIG array response */
      200: {
        content: {
          "application/json": components["schemas"]["STIG"][];
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** Assign a STIG to an Asset */
  attachStigToAsset: {
    parameters: {
      path: {
        assetId: components["parameters"]["AssetIdPath"];
        benchmarkId: components["parameters"]["BenchmarkIdPath"];
      };
    };
    responses: {
      /** @description STIG array response */
      200: {
        content: {
          "application/json": components["schemas"]["AssetStigResponse"][];
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** Delete a STIG assignment to an Asset */
  removeStigFromAsset: {
    parameters: {
      path: {
        assetId: components["parameters"]["AssetIdPath"];
        benchmarkId: components["parameters"]["BenchmarkIdPath"];
      };
    };
    responses: {
      /** @description STIG array response */
      200: {
        content: {
          "application/json": components["schemas"]["AssetStigResponse"][];
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** Return a list of Collections accessible to the requester */
  getCollections: {
    parameters: {
      query?: {
        elevate?: components["parameters"]["ElevateQuery"];
        name?: components["parameters"]["NameQuery"];
        "name-match"?: components["parameters"]["NameMatchQuery"];
        metadata?: components["parameters"]["MetadataQuery"];
        projection?: components["parameters"]["CollectionsProjectionQuery"];
      };
    };
    responses: {
      /** @description CollectionsProjected response */
      200: {
        content: {
          "application/json": components["schemas"]["CollectionsProjected"][];
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /**
   * Create a Collection
   * @description The `settings` property is optional and can be partially provided.
   * - If `settings` is not provided, the Collection will be created with the default settings.
   * - If a partial `settings` object is provided, the Collection will be created with settings merged from the provided object and the default settings.
   *
   * The default settings are:
   * ```
   *  {
   *     fields: {
   *       detail: {
   *         enabled: 'always',
   *         required: 'always'
   *       },
   *       comment: {
   *         enabled: 'findings',
   *         required: 'findings'
   *       }
   *     },
   *     status: {
   *       canAccept: true,
   *       resetCriteria: 'result',
   *       minAcceptGrant: 3
   *     },
   *     history: {
   *       maxReviews: 15
   *     }
   *   }
   * ```
   */
  createCollection: {
    parameters: {
      query?: {
        elevate?: components["parameters"]["ElevateQuery"];
        projection?: components["parameters"]["CollectionProjectionQuery"];
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CollectionCreateOrReplace"];
      };
    };
    responses: {
      /** @description CollectionProjected response */
      201: {
        content: {
          "application/json": components["schemas"]["CollectionProjected"];
        };
      };
      /** @description Client Error */
      400: {
        content: {
          "application/json": components["schemas"]["ClientErrorDuplicateCollection"];
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** Return a Collection */
  getCollection: {
    parameters: {
      query?: {
        elevate?: components["parameters"]["ElevateQuery"];
        projection?: components["parameters"]["CollectionProjectionQuery"];
      };
      path: {
        collectionId: components["parameters"]["CollectionIdPath"];
      };
    };
    responses: {
      /** @description CollectionProjected response */
      200: {
        content: {
          "application/json": components["schemas"]["CollectionProjected"];
        };
      };
      /** @description No Content */
      204: {
        content: never;
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /**
   * Set all properties of a Collection
   * @description See the description of path `POST /collections` for notes about the `settings` property
   */
  replaceCollection: {
    parameters: {
      query?: {
        elevate?: components["parameters"]["ElevateQuery"];
        projection?: components["parameters"]["CollectionProjectionQuery"];
      };
      path: {
        collectionId: components["parameters"]["CollectionIdPath"];
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CollectionCreateOrReplace"];
      };
    };
    responses: {
      /** @description CollectionProjected response */
      200: {
        content: {
          "application/json": components["schemas"]["CollectionProjected"];
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** Delete a Collection */
  deleteCollection: {
    parameters: {
      query?: {
        elevate?: components["parameters"]["ElevateQuery"];
        projection?: components["parameters"]["CollectionProjectionQuery"];
      };
      path: {
        collectionId: components["parameters"]["CollectionIdPath"];
      };
    };
    responses: {
      /** @description CollectionProjected response */
      200: {
        content: {
          "application/json": components["schemas"]["CollectionProjected"];
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /**
   * Merge provided properties with a Collection
   * @description The `settings` property can be partially provided. If a partial `settings` object is provided, the Collection settings will be updated to the provided object merged with the **default** settings. This sets existing property values not specified in the partial object to their default values.
   *
   * The default settings are found in the description of `POST /collection`
   */
  updateCollection: {
    parameters: {
      query?: {
        elevate?: components["parameters"]["ElevateQuery"];
        projection?: components["parameters"]["CollectionProjectionQuery"];
      };
      path: {
        collectionId: components["parameters"]["CollectionIdPath"];
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CollectionUpdate"];
      };
    };
    responses: {
      /** @description CollectionProjected response */
      200: {
        content: {
          "application/json": components["schemas"]["CollectionProjected"];
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** Return a ZIP archive containing CKL files for the supplied Assets and STIGs */
  postCklArchiveByCollection: {
    parameters: {
      query?: {
        mode?: components["parameters"]["CklModeQuery"];
      };
      path: {
        collectionId: components["parameters"]["CollectionIdPath"];
      };
    };
    /** @description An array of '#/components/schemas/AssetStigSelection'. */
    requestBody: {
      content: {
        "application/json": components["schemas"]["AssetStigSelection"][];
      };
    };
    responses: {
      /** @description ZIP file stream */
      200: {
        content: {
          "application/zip": string;
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** Return a ZIP archive containing CKLB files for the supplied Assets and STIGs */
  postCklbArchiveByCollection: {
    parameters: {
      query?: {
        mode?: components["parameters"]["CklModeQuery"];
      };
      path: {
        collectionId: components["parameters"]["CollectionIdPath"];
      };
    };
    /** @description An array of '#/components/schemas/AssetStigSelection'. */
    requestBody: {
      content: {
        "application/json": components["schemas"]["AssetStigSelection"][];
      };
    };
    responses: {
      /** @description ZIP file stream */
      200: {
        content: {
          "application/zip": string;
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** Return a ZIP archive containing XCCDF results for the supplied Assets and STIGs */
  postXccdfArchiveByCollection: {
    parameters: {
      path: {
        collectionId: components["parameters"]["CollectionIdPath"];
      };
    };
    /** @description An array of '#/components/schemas/AssetStigSelection'. */
    requestBody: {
      content: {
        "application/json": components["schemas"]["AssetStigSelection"][];
      };
    };
    responses: {
      /** @description ZIP file stream */
      200: {
        content: {
          "application/zip": string;
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** Return the Checklist for the supplied Collection and STIG */
  getChecklistByCollectionStig: {
    parameters: {
      path: {
        collectionId: components["parameters"]["CollectionIdPath"];
        benchmarkId: components["parameters"]["BenchmarkIdPath"];
        revisionStr: components["parameters"]["RevisionStrPath"];
      };
    };
    responses: {
      /** @description ChecklistCollectionStig response */
      200: {
        content: {
          "application/json": components["schemas"]["ChecklistCollectionStig"][];
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /**
   * Clone an existing Collection to a new Collection
   * @description Cloning large Collections can take several minutes! Users may see a performance impact when accessing the source Collection during this time.<br><br>Making changes to the source Collection while it is being cloned may lead to inconsistent results in the cloned Collection.<br><br><b>Before proceeding, it is recommended you warn Users that they refrain from modifying components of the source Collection while the cloning process is underway.</b>
   */
  cloneCollection: {
    parameters: {
      query?: {
        projection?: components["parameters"]["CollectionProjectionQuery"];
      };
      path: {
        collectionId: components["parameters"]["CollectionIdPath"];
      };
    };
    /** @description CollectionClone request body */
    requestBody: {
      content: {
        "application/json": components["schemas"]["CollectionCloneRequest"];
      };
    };
    responses: {
      /** @description See the description for '#/components/schemas/CollectionCloneResponse' */
      200: {
        content: {
          "application/x-ndjson": components["schemas"]["CollectionCloneResponse"];
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /**
   * Export reviews from a source Collection to a destination Collection
   * @description Exports reviews (result, detail and comment) from a `srcCollection` to a `dstCollection`, creating Assets in `dstCollection` if they do not exist. The `status` property of existing reviews in `dstCollection` are reset, if necessary, in accordance with the Collection settings.
   */
  exportToCollection: {
    parameters: {
      path: {
        collectionId: components["parameters"]["CollectionIdPath"];
        dstCollectionId: components["parameters"]["DstCollectionIdPath"];
      };
    };
    /** @description An array of '#/components/schemas/AssetStigSelection'. <b>The number of array items must conform to the minItems/maxItems properties</b> */
    requestBody: {
      content: {
        "application/json": components["schemas"]["AssetStigSelection"][];
      };
    };
    responses: {
      /** @description See the description for '#/components/schemas/CollectionExportToResponse' */
      200: {
        content: {
          "application/x-ndjson": components["schemas"]["CollectionExportToResponse"];
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** Return the Findings for the specified Collection */
  getFindingsByCollection: {
    parameters: {
      query: {
        aggregator: components["parameters"]["FindingAggregatorQuery"];
        acceptedOnly?: boolean;
        benchmarkId?: components["parameters"]["BenchmarkIdQuery"];
        assetId?: components["parameters"]["AssetIdQuery"];
        projection?: components["parameters"]["FindingProjectionQuery"];
      };
      path: {
        collectionId: components["parameters"]["CollectionIdPath"];
      };
    };
    responses: {
      /** @description CollectionFinding response */
      200: {
        content: {
          "application/json": components["schemas"]["FindingProjected"][];
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** Return an accessLevel = 1 User's access to the specified Collection. Request must be made by a User with accessLevel >= 3 to the Collection. */
  getStigAssetsByCollectionUser: {
    parameters: {
      path: {
        collectionId: components["parameters"]["CollectionIdPath"];
        userId: components["parameters"]["UserIdPath"];
      };
    };
    responses: {
      /** @description Collection StigAssetBasic array response */
      200: {
        content: {
          "application/json": components["schemas"]["StigAssetBasic"][];
        };
      };
      403: components["responses"]["Forbidden"];
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** Set an accessLevel = 1 User's access to the specified Collection. Request must be made by a User with accessLevel >= 3 to the Collection. */
  setStigAssetsByCollectionUser: {
    parameters: {
      path: {
        collectionId: components["parameters"]["CollectionIdPath"];
        userId: components["parameters"]["UserIdPath"];
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["StigAssetPut"][];
      };
    };
    responses: {
      /** @description StigAssetBasic array response */
      200: {
        content: {
          "application/json": components["schemas"]["StigAssetBasic"][];
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** Return a list of Reviews accessible to the requester */
  getReviewsByCollection: {
    parameters: {
      query?: {
        rules?: components["parameters"]["ReviewRulesQuery"];
        result?: components["parameters"]["ReviewResultQuery"];
        status?: components["parameters"]["ReviewStatusQuery"];
        ruleId?: components["parameters"]["RuleIdQuery"];
        groupId?: components["parameters"]["GroupIdQuery"];
        cci?: components["parameters"]["CciQuery"];
        userId?: components["parameters"]["UserIdQuery"];
        assetId?: components["parameters"]["AssetIdQuery"];
        benchmarkId?: components["parameters"]["BenchmarkIdQuery"];
        metadata?: components["parameters"]["MetadataQuery"];
        projection?: components["parameters"]["ReviewsProjectionQuery"];
      };
      path: {
        collectionId: components["parameters"]["CollectionIdPath"];
      };
    };
    responses: {
      /** @description Review response */
      200: {
        content: {
          "application/json": components["schemas"]["ReviewRead"][];
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /**
   * Insert, update, or merge a complete or partial Review to multiple Assets and Rules
   * @description
   * Applies a complete or partial Review to multiple target Asset/Rule pairs. Depending on the Review properties supplied, new Reviews may be created, existing Reviews may be updated, or both operations may occur (similar to an SQL merge).
   *
   * ## Caution
   *
   * **It is possible to send a request which will place the database under considerable load and take many seconds (or minutes) to complete. To determine if a request affects a large set of Reviews, clients are strongly encouraged to send a "preflight" request with the `dryRun` option enabled.**
   *
   * ## Request Validation
   *
   * The overall request is validated as follows:
   *
   * - conformance with the OAS schema for `ReviewBatch`
   * - the requesting user has been granted access to the {collectionId}
   *
   * ## Request body
   *
   * **source** *(required)*
   *
   *   The Review source is applied to the product of `assets` x `rules` (see below). It MUST contain at least one of the properties `result`, `detail`, `comment`, `resultEngine`, `metadata` or `status`.
   * - Multiple properties can be specified.
   * - a string value for the `status` property is normalized to `{ label: <string>, text: null }`
   *
   *
   * **assets** *(required)*
   *
   * The target Assets, which are specified as either:
   *   - an array of `assetId`
   *   - an array of `benchmarkId` where target Assets are calculated as the list of distinct Assets assigned at least one of the given STIGs, taking into account the requesting User's collection grant.
   *
   * **rules** *(required)*
   *
   * The target Rules, which are specified as either:
   *   - an array of `ruleId`
   *   - an array of `benchmarkId` where target Rules are calculated as the list of distinct Rules from all available revisions of the given STIGs.
   *
   * **action** *(optional)*
   *
   * Constrains the data action to be taken. If present, the value MUST be one of `insert`, `update`, or `merge`.
   *
   *   - `insert`: only create new Reviews, do not update existing Reviews
   *   - `update`: only update existing Reviews, do not create new Reviews
   *   - `merge`: create new Reviews and update existing Reviews
   *
   * If not present, the default value is:
   *
   *   - `merge` if the source Review includes `result`
   *   - `update` if the source Review does not include `result`
   *
   * New Reviews cannot be created when `source` does not include `result`. In that case, specifying either the `insert` or `merge` value is an error.
   *
   * **updateFilters** *(optional)*
   *
   * Limits the Reviews to be updated, based on an array of filtering objects. If present, updates are applied to Reviews from the product `assets` x `rules` that pass each of the filters (filters are combined with logical AND). If not present, updates are applied to each Review from the product `assets` x `rules`.
   *
   * Filtering objects specify a Review `field` , a `condition`, and a `value`. See the schema definition for further details.
   *
   * **dryRun** *(optional)*
   *
   * If present with a `true` value, performs all processing and validation logic without actually changing any data. Useful to verify what a given request would do and to reveal any validation errors. The default value is `false`.
   *
   * ## Review candidates
   *
   * Candidate Reviews are created by cross joining the source Review with the product of `assets` x `rules` and applying the resulting rows to existing Reviews (if any) in accordance with the Collection settings.
   *
   * **For updated Reviews**
   *
   * In general, an absent source Review property will retain existing values except as below.
   *
   * - an absent `status` property will either retain the existing value or update the `status` value to `{ label: "saved", text: "Review change triggered status update" }`, in accordance with the Collection `settings.status.resetCriteria`.
   * - an absent `resultEngine` property will either retain the existing value or update the `resultEngine` value to `null`. If applying the source Review changes an existing `result`, the `resultEngine` value will be set to `null`.
   *
   * **For new Reviews**
   *
   * - an absent `detail` or `comment` property will set the candidate value to the empty string.
   * - an absent `status` property will set the candidate value to `{ label: "saved", text: null }`.
   * - an absent `resultEngine` property will set the candidate value to `null`.
   * - an absent `metadata` property will set the candidate value to `{}`
   *
   * ## Candidate validation
   *
   * Each candidate Review is permitted or rejected as follows:
   *
   * - If the requesting user's collection grant is `restricted` AND the `ruleId` is not included in any version of any `benchmarkId` for which the requesting user been granted access, then **reject** the Review.
   * - If `status.label` has value `saved`, then permit the Review.
   * - If the Review would not be submittable according to the Collection settings, then **reject** the Review
   * - If the value of `status.label` is `submitted`, then **permit** the Review.
   * - If the value of `status.label` is `accepted` or `rejected` AND the Collection settings allow Reviews to be Accepted or Rejected, then **permit** the Review.
   * - If `status.label` has value `accepted` or `rejected` AND the Collection settings prohibit Reviews from being Accepted or Rejected, then **reject** the Review.
   */
  postReviewBatch: {
    parameters: {
      path: {
        collectionId: components["parameters"]["CollectionIdPath"];
      };
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["ReviewBatch"];
      };
    };
    responses: {
      /** @description ReviewBatchResponse response */
      200: {
        content: {
          "application/json": components["schemas"]["ReviewBatchResponse"] | components["schemas"]["ReviewBatchResponseDryRun"];
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** Return a list of Reviews for an Asset */
  getReviewsByAsset: {
    parameters: {
      query?: {
        rules?: components["parameters"]["ReviewRulesQuery"];
        result?: components["parameters"]["ReviewResultQuery"];
        status?: components["parameters"]["ReviewStatusQuery"];
        benchmarkId?: components["parameters"]["BenchmarkIdQuery"];
        metadata?: components["parameters"]["MetadataQuery"];
        projection?: components["parameters"]["ReviewsProjectionQuery"];
      };
      path: {
        collectionId: components["parameters"]["CollectionIdPath"];
        assetId: components["parameters"]["AssetIdPath"];
      };
    };
    responses: {
      /** @description ReviewAssetProjected response */
      200: {
        content: {
          "application/json": components["schemas"]["ReviewAsset"][];
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /**
   * Post one or more Reviews
   * @description The request body is an array that can contain both new and updated Reviews. All Reviews MUST contain the properties `ruleId`, `result`, `detail`, and `comment`. The overall request is validated as follows:
   *
   * - conformance with the OAS schema for `ReviewAssetPost`
   * - the requesting user has been granted access to the {collectionId}
   *
   * **For all Reviews**
   *
   * - a string value for the `status` property will set the stored value to `{ label: <string>, text: null }`
   * - an absent `resultEngine` property will set the stored value to `null`
   *
   * **For updated Reviews**
   *
   * - a `null` value for either `detail` or `comment` will retain the existing value.
   * - an absent `status` property will either retain the existing value or update the `status` value to `{ label: "saved", text: "Review change triggered status update" }`, in accordance with the Collection `settings.status.resetCriteria`.
   *
   * **For new Reviews**
   *
   * - a `null` value for either `detail` or `comment` will set the stored value to the empty string.
   * - an absent `status` property will set the stored value to `{ label: "saved", text: null }`.
   *
   * **Each new or updated Review is permitted or rejected as follows:**
   *
   * - If the requesting user's collection grant is `restricted` AND the `ruleId` is not included in any version of any `benchmarkId` for which the requesting user been granted access, then **reject** the Review
   * - If the optional property `status` is absent or `status.label` has value `saved`, then permit the Review
   * - If the new or updated Review would not be submittable according to the Collection settings, then **reject** the Review
   * - If the value of `status.label` is `submitted`, then **permit** the Review.
   * - If the value of `status.label` is `accepted` or `rejected` AND the Collection settings allow Reviews to be Accepted or Rejected, then **permit** the Review.
   * - If `status.label` has value `accepted` or `rejected` AND the Collection settings prohibit Reviews from being Accepted or Rejected, then **reject** the Review.
   */
  postReviewsByAsset: {
    parameters: {
      path: {
        collectionId: components["parameters"]["CollectionIdPath"];
        assetId: components["parameters"]["AssetIdPath"];
      };
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["ReviewAssetPost"][];
      };
    };
    responses: {
      /** @description ReviewPostResponse response */
      200: {
        content: {
          "application/json": components["schemas"]["ReviewPostResponse"];
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** Return the Review for an Asset and Rule */
  getReviewByAssetRule: {
    parameters: {
      query?: {
        projection?: components["parameters"]["ReviewProjectionQuery"];
      };
      path: {
        collectionId: components["parameters"]["CollectionIdPath"];
        assetId: components["parameters"]["AssetIdPath"];
        ruleId: components["parameters"]["RuleIdPath"];
      };
    };
    responses: {
      /** @description ReviewAssetRuleRead response */
      200: {
        content: {
          "application/json": components["schemas"]["ReviewAssetRuleRead"];
        };
      };
      /** @description The requested resource has no content. */
      204: {
        content: never;
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /**
   * Set all properties of a Review
   * @description The request can target either a new or an existing Review. The request body MUST contain the Review properties `result`, `detail`, and `comment`. The overall request is validated as follows:
   *
   * - conformance with the OAS schema for `ReviewAssetRulePut`
   * - the requesting user has been granted access to the {collectionId}
   *
   * **For all Reviews**
   *
   * - a string value for the `status` property will set the stored value to `{ label: <string>, text: null }`
   * - an absent `resultEngine` property will set the stored value to `resultEngine: null`
   *
   * **For updated Reviews**
   *
   * - a `null` value for either `detail` or `comment` will retain the existing value.
   * - an absent `status` property will either retain or update the `status` value to `{ label: "saved", text: "Review change triggered status update" }`, in accordance with the Collection `settings.status.resetCriteria`.
   *
   * **For new Reviews**
   *
   * - a `null` value for either `detail` or `comment` will set the stored value to the empty string.
   * - an absent `status` property will set the stored value to `{ label: "saved", text: null }`.
   *
   * The request is permitted or rejected as follows:
   *
   * - If the requesting user's collection grant is `restricted` AND the `assetId` is not included in any user grant, then **reject** the Review
   * - If the requesting user's collection grant is `restricted` AND the `ruleId` is not included in any version of any `benchmarkId` for which the user been granted access, then **reject** the Review
   * - If the new or updated Review would not be submittable according to the Collection settings, then **reject** the Review
   * - If the value of `status.label` is `submitted`, then **permit** the Review.
   * - If the value of `status.label` is `accepted` or `rejected` AND the Collection settings allow Reviews to be Accepted or Rejected, then **permit** the Review.
   * - If `status.label` has value `accepted` or `rejected` AND the Collection settings prohibit Reviews from being Accepted or Rejected, then **reject** the Review.
   */
  putReviewByAssetRule: {
    parameters: {
      query?: {
        projection?: components["parameters"]["ReviewProjectionQuery"];
      };
      path: {
        collectionId: components["parameters"]["CollectionIdPath"];
        assetId: components["parameters"]["AssetIdPath"];
        ruleId: components["parameters"]["RuleIdPath"];
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ReviewAssetRulePut"];
      };
    };
    responses: {
      /** @description ReviewProjected response */
      200: {
        content: {
          "application/json": components["schemas"]["ReviewAssetRuleRead"];
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** Delete a Review */
  deleteReviewByAssetRule: {
    parameters: {
      query?: {
        projection?: components["parameters"]["ReviewProjectionQuery"];
      };
      path: {
        collectionId: components["parameters"]["CollectionIdPath"];
        assetId: components["parameters"]["AssetIdPath"];
        ruleId: components["parameters"]["RuleIdPath"];
      };
    };
    responses: {
      /** @description ReviewProjected response */
      200: {
        content: {
          "application/json": components["schemas"]["ReviewAssetRuleRead"];
        };
      };
      /** @description No Content */
      204: {
        content: never;
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /**
   * Merge the provided properties with an existing Review
   * @description The request MUST target an existing Review and the request body MUST contain one or more Review properties. The overall request is validated as follows:
   *
   * - conformance with the OAS schema for `ReviewAssetRulePatch`
   * - the requesting user has been granted access to the {collectionId}
   * - a Review already exists for the {assetId} and {ruleId}
   *
   * A string value for the `status` property will set the stored value to `{ label: <string>, text: null }`.
   *
   * If the request changes the existing `result`, then the `resultEngine` value will be set to `null` unless the request includes an explicit `resultEngine` value.
   *
   * An absent `status` property may still lead to the `status` value being updated to `{ label: "saved", text: "Review change triggered status update" }`, in accordance with the Collection `settings.status.resetCriteria`.
   *
   * Unlike the corresponding PUT endpoint, the `detail` and `comment` properties do not support `null` as a value.
   *
   * The request is permitted or rejected as follows:
   *
   * - If the requesting user's collection grant is `restricted` AND the `assetId` is not included in any user grant, then **reject** the Review
   * - If the requesting user's collection grant is `restricted` AND the `ruleId` is not included in any version of any `benchmarkId` for which the user been granted access, then **reject** the Review
   * - If the new or updated Review would not be submittable according to the Collection settings, then **reject** the Review
   * - If the value of `status.label` is `submitted`, then **permit** the Review.
   * - If the value of `status.label` is `accepted` or `rejected` AND the Collection settings allow Reviews to be Accepted or Rejected, then **permit** the Review.
   * - If `status.label` has value `accepted` or `rejected` AND the Collection settings prohibit Reviews from being Accepted or Rejected, then **reject** the Review.
   */
  patchReviewByAssetRule: {
    parameters: {
      query?: {
        projection?: components["parameters"]["ReviewProjectionQuery"];
      };
      path: {
        collectionId: components["parameters"]["CollectionIdPath"];
        assetId: components["parameters"]["AssetIdPath"];
        ruleId: components["parameters"]["RuleIdPath"];
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ReviewAssetRulePatch"];
      };
    };
    responses: {
      /** @description ReviewProjected response */
      200: {
        content: {
          "application/json": components["schemas"]["ReviewAssetRuleRead"];
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** Return the metadata for Review */
  getReviewMetadata: {
    parameters: {
      path: {
        collectionId: components["parameters"]["CollectionIdPath"];
        assetId: components["parameters"]["AssetIdPath"];
        ruleId: components["parameters"]["RuleIdPath"];
      };
    };
    responses: {
      /** @description Metadata response */
      200: {
        content: {
          "application/json": components["schemas"]["Metadata"];
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** Set a Review metadata to the provided object */
  putReviewMetadata: {
    parameters: {
      path: {
        collectionId: components["parameters"]["CollectionIdPath"];
        assetId: components["parameters"]["AssetIdPath"];
        ruleId: components["parameters"]["RuleIdPath"];
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["Metadata"];
      };
    };
    responses: {
      /** @description Metadata response */
      200: {
        content: {
          "application/json": components["schemas"]["Metadata"];
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** Merge the provided object to a Review metadata */
  patchReviewMetadata: {
    parameters: {
      path: {
        collectionId: components["parameters"]["CollectionIdPath"];
        assetId: components["parameters"]["AssetIdPath"];
        ruleId: components["parameters"]["RuleIdPath"];
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["Metadata"];
      };
    };
    responses: {
      /** @description Metadata response */
      200: {
        content: {
          "application/json": components["schemas"]["Metadata"];
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** Return the keys of the provided Review's metadata */
  getReviewMetadataKeys: {
    parameters: {
      path: {
        collectionId: components["parameters"]["CollectionIdPath"];
        assetId: components["parameters"]["AssetIdPath"];
        ruleId: components["parameters"]["RuleIdPath"];
      };
    };
    responses: {
      /** @description MetadataKeys response */
      200: {
        content: {
          "application/json": components["schemas"]["MetadataKey"][];
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** Return the value of the provided Review metadata key */
  getReviewMetadataValue: {
    parameters: {
      path: {
        collectionId: components["parameters"]["CollectionIdPath"];
        assetId: components["parameters"]["AssetIdPath"];
        ruleId: components["parameters"]["RuleIdPath"];
        key: components["parameters"]["MetadataKeyPath"];
      };
    };
    responses: {
      /** @description MetadataValue response */
      200: {
        content: {
          "application/json": components["schemas"]["MetadataValue"];
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** Set the value of the provided Review metadata key to the provided string */
  putReviewMetadataValue: {
    parameters: {
      path: {
        collectionId: components["parameters"]["CollectionIdPath"];
        assetId: components["parameters"]["AssetIdPath"];
        ruleId: components["parameters"]["RuleIdPath"];
        key: components["parameters"]["MetadataKeyPath"];
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["MetadataValue"];
      };
    };
    responses: {
      /** @description Empty to avoid large response after putting key with large value */
      204: {
        content: never;
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** Remove the provided Review metadata key */
  deleteReviewMetadataKey: {
    parameters: {
      path: {
        collectionId: components["parameters"]["CollectionIdPath"];
        assetId: components["parameters"]["AssetIdPath"];
        ruleId: components["parameters"]["RuleIdPath"];
        key: components["parameters"]["MetadataKeyPath"];
      };
    };
    responses: {
      /** @description Empty to avoid large response after deleting key with large value */
      204: {
        content: never;
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** Return labels of the specified Collection */
  getCollectionLabels: {
    parameters: {
      path: {
        collectionId: components["parameters"]["CollectionIdPath"];
      };
    };
    responses: {
      /** @description Labels response */
      200: {
        content: {
          "application/json": components["schemas"]["Label"][];
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** Create a label in the specified Collection */
  createCollectionLabel: {
    parameters: {
      path: {
        collectionId: components["parameters"]["CollectionIdPath"];
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["LabelCreate"];
      };
    };
    responses: {
      /** @description Label response */
      201: {
        content: {
          "application/json": components["schemas"]["Label"];
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** Return the specified Label of the specified Collection */
  getCollectionLabelById: {
    parameters: {
      path: {
        collectionId: components["parameters"]["CollectionIdPath"];
        labelId: components["parameters"]["LabelIdPath"];
      };
    };
    responses: {
      /** @description Labels response */
      200: {
        content: {
          "application/json": components["schemas"]["Label"];
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** Delete a Label */
  deleteCollectionLabelById: {
    parameters: {
      path: {
        collectionId: components["parameters"]["CollectionIdPath"];
        labelId: components["parameters"]["LabelIdPath"];
      };
    };
    responses: {
      /** @description No Content */
      204: {
        content: never;
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** Update an existing Label */
  patchCollectionLabelById: {
    parameters: {
      path: {
        collectionId: components["parameters"]["CollectionIdPath"];
        labelId: components["parameters"]["LabelIdPath"];
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["LabelUpdate"];
      };
    };
    responses: {
      /** @description Label response */
      200: {
        content: {
          "application/json": components["schemas"]["Label"];
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** Return the Assets mapped to the Label */
  getAssetsByCollectionLabelId: {
    parameters: {
      path: {
        collectionId: components["parameters"]["CollectionIdPath"];
        labelId: components["parameters"]["LabelIdPath"];
      };
    };
    responses: {
      /** @description Asset response */
      200: {
        content: {
          "application/json": components["schemas"]["AssetBasic"][];
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** Replace the Label's Asset mappings */
  putAssetsByCollectionLabelId: {
    parameters: {
      path: {
        collectionId: components["parameters"]["CollectionIdPath"];
        labelId: components["parameters"]["LabelIdPath"];
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["String255"][];
      };
    };
    responses: {
      /** @description The Label's Asset mappings */
      200: {
        content: {
          "application/json": components["schemas"]["AssetBasic"][];
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** Return the metadata for Collection */
  getCollectionMetadata: {
    parameters: {
      query?: {
        elevate?: components["parameters"]["ElevateQuery"];
      };
      path: {
        collectionId: components["parameters"]["CollectionIdPath"];
      };
    };
    responses: {
      /** @description Metadata response */
      200: {
        content: {
          "application/json": components["schemas"]["Metadata"];
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** Set a Collection metadata to the provided object */
  putCollectionMetadata: {
    parameters: {
      query?: {
        elevate?: components["parameters"]["ElevateQuery"];
      };
      path: {
        collectionId: components["parameters"]["CollectionIdPath"];
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["Metadata"];
      };
    };
    responses: {
      /** @description Metadata response */
      200: {
        content: {
          "application/json": components["schemas"]["Metadata"];
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** Merge the provided object to a Collection metadata */
  patchCollectionMetadata: {
    parameters: {
      query?: {
        elevate?: components["parameters"]["ElevateQuery"];
      };
      path: {
        collectionId: components["parameters"]["CollectionIdPath"];
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["Metadata"];
      };
    };
    responses: {
      /** @description Metadata response */
      200: {
        content: {
          "application/json": components["schemas"]["Metadata"];
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** Return the keys of the provided Collection metadata */
  getCollectionMetadataKeys: {
    parameters: {
      query?: {
        elevate?: components["parameters"]["ElevateQuery"];
      };
      path: {
        collectionId: components["parameters"]["CollectionIdPath"];
      };
    };
    responses: {
      /** @description MetadataKeys response */
      200: {
        content: {
          "application/json": components["schemas"]["MetadataKey"][];
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** Return the value of the provided Collection metadata key */
  getCollectionMetadataValue: {
    parameters: {
      query?: {
        elevate?: components["parameters"]["ElevateQuery"];
      };
      path: {
        collectionId: components["parameters"]["CollectionIdPath"];
        key: components["parameters"]["MetadataKeyPath"];
      };
    };
    responses: {
      /** @description MetadataValue response */
      200: {
        content: {
          "application/json": components["schemas"]["MetadataValue"];
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** Set the value of the provided Collection metadata key to the provided string */
  putCollectionMetadataValue: {
    parameters: {
      query?: {
        elevate?: components["parameters"]["ElevateQuery"];
      };
      path: {
        collectionId: components["parameters"]["CollectionIdPath"];
        key: components["parameters"]["MetadataKeyPath"];
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["MetadataValue"];
      };
    };
    responses: {
      /** @description Empty to avoid large response after putting key with large value */
      204: {
        content: never;
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** Remove the provided Collection metadata key */
  deleteCollectionMetadataKey: {
    parameters: {
      query?: {
        elevate?: components["parameters"]["ElevateQuery"];
      };
      path: {
        collectionId: components["parameters"]["CollectionIdPath"];
        key: components["parameters"]["MetadataKeyPath"];
      };
    };
    responses: {
      /** @description Empty to avoid large response after deleting key with large value */
      204: {
        content: never;
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** Return unaggregated Asset/STIG metrics for the specified Collection */
  getMetricsDetailByCollection: {
    parameters: {
      query?: {
        benchmarkId?: components["parameters"]["BenchmarkIdArrayQuery"];
        assetId?: components["parameters"]["AssetIdArrayQuery"];
        labelId?: components["parameters"]["LabelIdQuery"];
        labelName?: components["parameters"]["LabelNameQuery"];
        labelMatch?: components["parameters"]["LabelMatchQuery"];
        format?: components["parameters"]["MetricsFormatQuery"];
      };
      path: {
        collectionId: components["parameters"]["CollectionIdPath"];
      };
    };
    responses: {
      /** @description Metrics response */
      200: {
        content: {
          "application/json": components["schemas"]["MetricsDetailUnagg"][];
          "text/csv": string;
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** Return metrics for the specified Collection aggregated by Asset */
  getMetricsDetailByCollectionAggAsset: {
    parameters: {
      query?: {
        benchmarkId?: components["parameters"]["BenchmarkIdArrayQuery"];
        assetId?: components["parameters"]["AssetIdArrayQuery"];
        labelId?: components["parameters"]["LabelIdQuery"];
        labelName?: components["parameters"]["LabelNameQuery"];
        labelMatch?: components["parameters"]["LabelMatchQuery"];
        format?: components["parameters"]["MetricsFormatQuery"];
      };
      path: {
        collectionId: components["parameters"]["CollectionIdPath"];
      };
    };
    responses: {
      /** @description Metrics response */
      200: {
        content: {
          "application/json": components["schemas"]["MetricsDetailAggAsset"][];
          "text/csv": string;
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** Return aggregated metrics for the specified Collection */
  getMetricsDetailByCollectionAgg: {
    parameters: {
      query?: {
        benchmarkId?: components["parameters"]["BenchmarkIdArrayQuery"];
        assetId?: components["parameters"]["AssetIdArrayQuery"];
        labelId?: components["parameters"]["LabelIdQuery"];
        labelName?: components["parameters"]["LabelNameQuery"];
        labelMatch?: components["parameters"]["LabelMatchQuery"];
        format?: components["parameters"]["MetricsFormatQuery"];
      };
      path: {
        collectionId: components["parameters"]["CollectionIdPath"];
      };
    };
    responses: {
      /** @description Metrics response */
      200: {
        content: {
          "application/json": components["schemas"]["MetricsDetailAggCollection"];
          "text/csv": string;
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** Return metrics for the specified Collection aggregated by Label */
  getMetricsDetailByCollectionAggLabel: {
    parameters: {
      query?: {
        benchmarkId?: components["parameters"]["BenchmarkIdArrayQuery"];
        assetId?: components["parameters"]["AssetIdArrayQuery"];
        labelId?: components["parameters"]["LabelIdQuery"];
        labelName?: components["parameters"]["LabelNameQuery"];
        labelMatch?: components["parameters"]["LabelMatchQuery"];
        format?: components["parameters"]["MetricsFormatQuery"];
      };
      path: {
        collectionId: components["parameters"]["CollectionIdPath"];
      };
    };
    responses: {
      /** @description Metrics response */
      200: {
        content: {
          "application/json": components["schemas"]["MetricsDetailAggLabel"][];
          "text/csv": string;
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** Return metrics for the specified Collection aggregated by STIG */
  getMetricsDetailByCollectionAggStig: {
    parameters: {
      query?: {
        benchmarkId?: components["parameters"]["BenchmarkIdArrayQuery"];
        assetId?: components["parameters"]["AssetIdArrayQuery"];
        labelId?: components["parameters"]["LabelIdQuery"];
        labelName?: components["parameters"]["LabelNameQuery"];
        labelMatch?: components["parameters"]["LabelMatchQuery"];
        format?: components["parameters"]["MetricsFormatQuery"];
      };
      path: {
        collectionId: components["parameters"]["CollectionIdPath"];
      };
    };
    responses: {
      /** @description Metrics response */
      200: {
        content: {
          "application/json": components["schemas"]["MetricsDetailAggStig"][];
          "text/csv": string;
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** Return unaggregated Asset/STIG metrics for the specified Collection */
  getMetricsSummaryByCollection: {
    parameters: {
      query?: {
        benchmarkId?: components["parameters"]["BenchmarkIdArrayQuery"];
        assetId?: components["parameters"]["AssetIdArrayQuery"];
        labelId?: components["parameters"]["LabelIdQuery"];
        labelName?: components["parameters"]["LabelNameQuery"];
        labelMatch?: components["parameters"]["LabelMatchQuery"];
        format?: components["parameters"]["MetricsFormatQuery"];
      };
      path: {
        collectionId: components["parameters"]["CollectionIdPath"];
      };
    };
    responses: {
      /** @description Metrics response */
      200: {
        content: {
          "application/json": components["schemas"]["MetricsSummaryUnagg"][];
          "text/csv": string;
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** Return metrics for the specified Collection aggregated by Asset */
  getMetricsSummaryByCollectionAggAsset: {
    parameters: {
      query?: {
        benchmarkId?: components["parameters"]["BenchmarkIdArrayQuery"];
        assetId?: components["parameters"]["AssetIdArrayQuery"];
        labelId?: components["parameters"]["LabelIdQuery"];
        labelName?: components["parameters"]["LabelNameQuery"];
        labelMatch?: components["parameters"]["LabelMatchQuery"];
        format?: components["parameters"]["MetricsFormatQuery"];
      };
      path: {
        collectionId: components["parameters"]["CollectionIdPath"];
      };
    };
    responses: {
      /** @description Metrics response */
      200: {
        content: {
          "application/json": components["schemas"]["MetricsSummaryAggAsset"][];
          "text/csv": string;
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** Return aggregated metrics for the specified Collection */
  getMetricsSummaryByCollectionAgg: {
    parameters: {
      query?: {
        benchmarkId?: components["parameters"]["BenchmarkIdArrayQuery"];
        assetId?: components["parameters"]["AssetIdArrayQuery"];
        labelId?: components["parameters"]["LabelIdQuery"];
        labelName?: components["parameters"]["LabelNameQuery"];
        labelMatch?: components["parameters"]["LabelMatchQuery"];
        format?: components["parameters"]["MetricsFormatQuery"];
      };
      path: {
        collectionId: components["parameters"]["CollectionIdPath"];
      };
    };
    responses: {
      /** @description Metrics response */
      200: {
        content: {
          "application/json": components["schemas"]["MetricsSummaryAggCollection"];
          "text/csv": string;
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** Return metrics for the specified Collection aggregated by Label */
  getMetricsSummaryByCollectionAggLabel: {
    parameters: {
      query?: {
        benchmarkId?: components["parameters"]["BenchmarkIdArrayQuery"];
        assetId?: components["parameters"]["AssetIdArrayQuery"];
        labelId?: components["parameters"]["LabelIdQuery"];
        labelName?: components["parameters"]["LabelNameQuery"];
        labelMatch?: components["parameters"]["LabelMatchQuery"];
        format?: components["parameters"]["MetricsFormatQuery"];
      };
      path: {
        collectionId: components["parameters"]["CollectionIdPath"];
      };
    };
    responses: {
      /** @description Metrics response */
      200: {
        content: {
          "application/json": components["schemas"]["MetricsSummaryAggLabel"][];
          "text/csv": string;
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** Return metrics for the specified Collection aggregated by STIG */
  getMetricsSummaryByCollectionAggStig: {
    parameters: {
      query?: {
        benchmarkId?: components["parameters"]["BenchmarkIdArrayQuery"];
        assetId?: components["parameters"]["AssetIdArrayQuery"];
        labelId?: components["parameters"]["LabelIdQuery"];
        labelName?: components["parameters"]["LabelNameQuery"];
        labelMatch?: components["parameters"]["LabelMatchQuery"];
        format?: components["parameters"]["MetricsFormatQuery"];
      };
      path: {
        collectionId: components["parameters"]["CollectionIdPath"];
      };
    };
    responses: {
      /** @description Metrics response */
      200: {
        content: {
          "application/json": components["schemas"]["MetricsSummaryAggStig"][];
          "text/csv": string;
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** Return a POAM-like spreadsheet for the specified Collection aggregated by groupId */
  getPoamByCollection: {
    parameters: {
      query: {
        aggregator: components["parameters"]["PoamAggregatorQuery"];
        acceptedOnly?: boolean;
        benchmarkId?: components["parameters"]["BenchmarkIdQuery"];
        assetId?: components["parameters"]["AssetIdQuery"];
        /** @description Value for columns Scheduled Completion Date, Milestone With Completion Dates, Milestone Changes */
        date?: string;
        /** @description Value for column Office/Org */
        office?: string;
        /** @description Value for column Status */
        status?: string;
      };
      path: {
        collectionId: components["parameters"]["CollectionIdPath"];
      };
    };
    responses: {
      /** @description CollectionFinding response */
      200: {
        content: {
          "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": string;
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** Return history records for the specified Collection that meet the specified criteria */
  getReviewHistoryByCollection: {
    parameters: {
      query?: {
        startDate?: components["parameters"]["StartDateQuery"];
        endDate?: components["parameters"]["EndDateQuery"];
        assetId?: components["parameters"]["AssetIdQuery"];
        ruleId?: components["parameters"]["RuleIdQuery"];
        status?: components["parameters"]["ReviewStatusQuery"];
      };
      path: {
        collectionId: components["parameters"]["CollectionIdPath"];
      };
    };
    responses: {
      /** @description ReviewHistory response */
      200: {
        content: {
          "application/json": components["schemas"]["ReviewHistoryAsset"][];
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** Remove history records that meet specified criteria */
  deleteReviewHistoryByCollection: {
    parameters: {
      query: {
        retentionDate: components["parameters"]["RetentionDateQuery"];
        assetId?: components["parameters"]["AssetIdQuery"];
      };
      path: {
        collectionId: components["parameters"]["CollectionIdPath"];
      };
    };
    responses: {
      /** @description Number of history records deleted. */
      200: {
        content: {
          "application/json": components["schemas"]["ReviewHistoryDeleted"];
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** Return history statistics for the specified Collection */
  getReviewHistoryStatsByCollection: {
    parameters: {
      query?: {
        startDate?: components["parameters"]["StartDateQuery"];
        endDate?: components["parameters"]["EndDateQuery"];
        assetId?: components["parameters"]["AssetIdQuery"];
        ruleId?: components["parameters"]["RuleIdQuery"];
        status?: components["parameters"]["ReviewStatusQuery"];
        projection?: components["parameters"]["ReviewHistoryStatsProjectionQuery"];
      };
      path: {
        collectionId: components["parameters"]["CollectionIdPath"];
      };
    };
    responses: {
      /** @description ReviewHistoryStats response */
      200: {
        content: {
          "application/json": components["schemas"]["ReviewHistoryStats"];
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** DEPRECATED - targeted for removal soon, please use the Metrics endpoints */
  getStatusByCollection: {
    parameters: {
      query?: {
        benchmarkId?: components["parameters"]["BenchmarkIdArrayQuery"];
        assetId?: components["parameters"]["AssetIdArrayQuery"];
      };
      path: {
        collectionId: components["parameters"]["CollectionIdPath"];
      };
    };
    responses: {
      /** @description Metrics response */
      200: {
        content: {
          "application/json": components["schemas"]["CollectionStatus"][];
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** Return the STIGs mapped in the specified Collection */
  getStigsByCollection: {
    parameters: {
      query?: {
        labelId?: components["parameters"]["LabelIdQuery"];
        labelName?: components["parameters"]["LabelNameQuery"];
        labelMatch?: components["parameters"]["LabelMatchQuery"];
        projection?: components["parameters"]["CollectionStigProjectionQuery"];
      };
      path: {
        collectionId: components["parameters"]["CollectionIdPath"];
      };
    };
    responses: {
      /** @description Collection STIGs array response */
      200: {
        content: {
          "application/json": components["schemas"]["CollectionStigWithAssetCount"][];
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** Return the STIG mapped in the specified Collection */
  getStigByCollection: {
    parameters: {
      query?: {
        projection?: components["parameters"]["CollectionStigProjectionQuery"];
      };
      path: {
        collectionId: components["parameters"]["CollectionIdPath"];
        benchmarkId: components["parameters"]["BenchmarkIdPath"];
      };
    };
    responses: {
      /** @description Collection STIGs array response */
      200: {
        content: {
          "application/json": components["schemas"]["CollectionStigWithAssetCount"];
        };
      };
      /** @description No content because STIG is not assigned */
      204: {
        content: never;
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /**
   * Set the default Revision and/or the Asset list of a STIG in a Collection
   * @description Neither of the request body properties is required but at least one must be present. If the path parameter `{benchmarkId}` is not already mapped to at least one Asset in `{collectionId}`, then the `assetIds` property must be present.
   */
  writeStigPropsByCollectionStig: {
    parameters: {
      query?: {
        projection?: components["parameters"]["CollectionStigProjectionQuery"];
      };
      path: {
        collectionId: components["parameters"]["CollectionIdPath"];
        benchmarkId: components["parameters"]["BenchmarkIdPath"];
      };
    };
    requestBody: {
      content: {
        "application/json": {
          defaultRevisionStr?: components["schemas"]["RevisionStr"];
          assetIds?: components["schemas"]["StringIntId"][];
        };
      };
    };
    responses: {
      /** @description Default Revision response */
      200: {
        content: {
          "application/json": components["schemas"]["CollectionStigWithAssetCount"];
        };
      };
      /** @description No content because STIG is not assigned */
      204: {
        content: never;
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** Get the Assets in a Collection attached to a STIG */
  getAssetsByStig: {
    parameters: {
      query?: {
        projection?: components["parameters"]["StigAssetsProjectionQuery"];
        labelId?: components["parameters"]["LabelIdQuery"];
        labelName?: components["parameters"]["LabelNameQuery"];
        labelMatch?: components["parameters"]["LabelMatchQuery"];
      };
      path: {
        collectionId: components["parameters"]["CollectionIdPath"];
        benchmarkId: components["parameters"]["BenchmarkIdPath"];
      };
    };
    responses: {
      /** @description AssetBasicProjected response */
      200: {
        content: {
          "application/json": components["schemas"]["AssetBasicProjected"][];
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** Set the Assets mapped to a STIG */
  attachAssetsToStig: {
    parameters: {
      query?: {
        projection?: components["parameters"]["StigAssetsProjectionQuery"];
      };
      path: {
        collectionId: components["parameters"]["CollectionIdPath"];
        benchmarkId: components["parameters"]["BenchmarkIdPath"];
      };
    };
    /** @description A list of assetIds from the specified Collection */
    requestBody: {
      content: {
        "application/json": string[];
      };
    };
    responses: {
      /** @description AssetBasicProjected response */
      200: {
        content: {
          "application/json": components["schemas"]["AssetBasicProjected"][];
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** EXPERIMENTAL - Return the Assets in the specified Collection with unreviewed Rules */
  getUnreviewedAssetsByCollection: {
    parameters: {
      query?: {
        assetId?: components["parameters"]["AssetIdQuery"];
        labelId?: components["parameters"]["LabelIdQuery"];
        labelName?: components["parameters"]["LabelNameQuery"];
        benchmarkId?: components["parameters"]["BenchmarkIdQuery"];
        severity?: components["parameters"]["RuleSeverityQuery"];
        projection?: components["parameters"]["UnreviewedAssetsProjectionQuery"];
      };
      path: {
        collectionId: components["parameters"]["CollectionIdPath"];
      };
    };
    responses: {
      /** @description UnreviewedAsset response */
      200: {
        content: {
          "application/json": components["schemas"]["UnreviewedAsset"][];
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** EXPERIMENTAL - Return the Rules in the specified Collection with unreviewed Assets */
  getUnreviewedRulesByCollection: {
    parameters: {
      query?: {
        ruleId?: components["parameters"]["RuleIdQuery"];
        labelId?: components["parameters"]["LabelIdQuery"];
        labelName?: components["parameters"]["LabelNameQuery"];
        benchmarkId?: components["parameters"]["BenchmarkIdQuery"];
        severity?: components["parameters"]["RuleSeverityQuery"];
        projection?: components["parameters"]["UnreviewedRulesProjectionQuery"];
      };
      path: {
        collectionId: components["parameters"]["CollectionIdPath"];
      };
    };
    responses: {
      /** @description UnreviewedRules response */
      200: {
        content: {
          "application/json": components["schemas"]["UnreviewedRule"][];
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** Export application data */
  getAppData: {
    parameters: {
      query?: {
        elevate?: components["parameters"]["ElevateQuery"];
      };
    };
    responses: {
      /** @description Exported data */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** Import and overwrite application data */
  replaceAppData: {
    parameters: {
      query?: {
        elevate?: components["parameters"]["ElevateQuery"];
      };
    };
    requestBody?: {
      content: {
        "application/json": {
          collections?: string;
        };
        "multipart/form-data": {
          /** Format: binary */
          importFile?: string;
        };
      };
    };
    responses: {
      /** @description Import successful */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** Return API version and configuration information */
  getConfiguration: {
    responses: {
      /** @description Configuration response */
      200: {
        content: {
          "application/json": components["schemas"]["ApiConfiguration"];
        };
      };
    };
  };
  /** Return the API definition */
  getDefinition: {
    parameters: {
      query?: {
        jsonpath?: components["parameters"]["JsonPathQuery"];
      };
    };
    responses: {
      /** @description Definition response */
      200: {
        content: {
          "application/json": components["schemas"]["ApiDefinition"];
        };
      };
    };
  };
  /** Return deployment details */
  getDetails: {
    parameters: {
      query?: {
        elevate?: components["parameters"]["ElevateQuery"];
      };
    };
    responses: {
      /** @description Detail response */
      200: {
        content: {
          "application/json": components["schemas"]["Detail"];
        };
      };
    };
  };
  /** Return a list of available STIGs */
  getSTIGs: {
    parameters: {
      query?: {
        /** @description A string found anywhere in a STIG title */
        title?: string;
        projection?: components["parameters"]["StigProjectionQuery"];
        elevate?: components["parameters"]["ElevateQuery"];
      };
    };
    responses: {
      /** @description STIG response */
      200: {
        content: {
          "application/json": components["schemas"]["STIG"][];
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** Import a STIG Benchmark */
  importBenchmark: {
    parameters: {
      query?: {
        /** @description Should existing Revision data be overwritten */
        clobber?: boolean;
      };
    };
    requestBody: {
      content: {
        "multipart/form-data": {
          /** Format: binary */
          importFile?: string;
        };
      };
    };
    responses: {
      /** @description The added STIG */
      200: {
        content: {
          "application/json": components["schemas"]["RevisionPost"];
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** Return data for the specified CCI */
  getCci: {
    parameters: {
      query?: {
        projection?: components["parameters"]["CciProjectionQuery"];
      };
      path: {
        /** @description A path parameter that identifies a CCI */
        cci: string;
      };
    };
    responses: {
      /** @description CCI response */
      200: {
        content: {
          "application/json": components["schemas"]["Cci"];
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** Return the defintion and associated check and fix for the specified Rule */
  getRuleByRuleId: {
    parameters: {
      query?: {
        projection?: components["parameters"]["RuleProjectionQuery"];
      };
      path: {
        /** @description A path parameter that identifies a Rule */
        ruleId: string;
      };
    };
    responses: {
      /** @description Rule response */
      200: {
        content: {
          "application/json": components["schemas"]["RuleProjected"];
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** Return a list of SCAP benchmarkIds mapped to Manual benchmarkIds */
  getScapMap: {
    responses: {
      /** @description SCAP Map response */
      200: {
        content: {
          "application/json": components["schemas"]["SCAPMap"][];
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** Return properties of the specified STIG */
  getStigById: {
    parameters: {
      query?: {
        elevate?: components["parameters"]["ElevateQuery"];
      };
      path: {
        /** @description A path parameter that identifies a STIG */
        benchmarkId: string;
      };
    };
    responses: {
      /** @description STIG response */
      200: {
        content: {
          "application/json": components["schemas"]["STIG"];
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** Deletes a STIG (*** and all revisions ***) */
  deleteStigById: {
    parameters: {
      query?: {
        elevate?: components["parameters"]["ElevateQuery"];
        force?: components["parameters"]["ForceQuery"];
      };
      path: {
        /** @description A path parameter that identifies a STIG */
        benchmarkId: string;
      };
    };
    responses: {
      /** @description The deleted STIG */
      200: {
        content: {
          "application/json": components["schemas"]["STIG"];
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** Return a list of revisions for the specified STIG */
  getRevisionsByBenchmarkId: {
    parameters: {
      query?: {
        elevate?: components["parameters"]["ElevateQuery"];
      };
      path: {
        /** @description A path parameter that identifies a STIG */
        benchmarkId: string;
      };
    };
    responses: {
      /** @description Revision response */
      200: {
        content: {
          "application/json": components["schemas"]["Revision"][];
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** Return metadata for the specified revision of a STIG */
  getRevisionByString: {
    parameters: {
      query?: {
        elevate?: components["parameters"]["ElevateQuery"];
      };
      path: {
        /** @description A path parameter that identifies a STIG */
        benchmarkId: string;
        /** @description A path parameter that identifies a STIG revision [V{version_num}R{release_num} | 'latest' ] */
        revisionStr: string;
      };
    };
    responses: {
      /** @description Revision response */
      200: {
        content: {
          "application/json": components["schemas"]["Revision"];
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** Deletes the specified revision of a STIG */
  deleteRevisionByString: {
    parameters: {
      query?: {
        elevate?: components["parameters"]["ElevateQuery"];
        force?: components["parameters"]["ForceQuery"];
      };
      path: {
        /** @description A path parameter that identifies a STIG */
        benchmarkId: string;
        /** @description A path parameter that identifies a STIG revision [V{version_num}R{release_num} | 'latest' ] */
        revisionStr: string;
      };
    };
    responses: {
      /** @description The deleted Revision */
      200: {
        content: {
          "application/json": components["schemas"]["Revision"];
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** Return a list of CCIs from a STIG revision */
  getCcisByRevision: {
    parameters: {
      path: {
        /** @description A path parameter that identifies a STIG */
        benchmarkId: string;
        /** @description A path parameter that identifies a STIG revision [V{version_num}R{release_num} | 'latest' ] */
        revisionStr: string;
      };
    };
    responses: {
      /** @description CCI response */
      200: {
        content: {
          "application/json": components["schemas"]["CciListItem"][];
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** Return the list of groups for the specified revision of a STIG. */
  getGroupsByRevision: {
    parameters: {
      query?: {
        projection?: components["parameters"]["GroupProjectionQuery"];
      };
      path: {
        /** @description A path parameter that identifies a STIG */
        benchmarkId: string;
        /** @description A path parameter that identifies a STIG revision [V{version_num}R{release_num} | 'latest' ] */
        revisionStr: string;
      };
    };
    responses: {
      /** @description GroupProjected response */
      200: {
        content: {
          "application/json": components["schemas"]["GroupProjected"][];
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /**
   * Return the rules, checks and fixes for a Group from a specified revision of a STIG.
   * @description None
   */
  getGroupByRevision: {
    parameters: {
      query?: {
        projection?: components["parameters"]["GroupProjectionQuery"];
      };
      path: {
        /** @description A path parameter that identifies a STIG */
        benchmarkId: string;
        /** @description A path parameter that identifies a STIG revision [V{version_num}R{release_num} | 'latest' ] */
        revisionStr: string;
        /** @description A path parameter that identifies a Group */
        groupId: string;
      };
    };
    responses: {
      /** @description Group response */
      200: {
        content: {
          "application/json": components["schemas"]["GroupProjected"];
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** Return rule data for the specified revision of a STIG. */
  getRulesByRevision: {
    parameters: {
      query?: {
        projection?: components["parameters"]["RuleProjectionQuery"];
      };
      path: {
        /** @description A path parameter that identifies a STIG */
        benchmarkId: string;
        /** @description A path parameter that identifies a STIG revision [V{version_num}R{release_num} | 'latest' ] */
        revisionStr: string;
      };
    };
    responses: {
      /** @description Rule response */
      200: {
        content: {
          "application/json": components["schemas"]["RuleProjected"][];
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** Return rule data for the specified Rule in a revision of a STIG. */
  getRuleByRevision: {
    parameters: {
      query?: {
        projection?: components["parameters"]["RuleProjectionQuery"];
      };
      path: {
        /** @description A path parameter that identifies a STIG */
        benchmarkId: string;
        /** @description A path parameter that identifies a STIG revision [V{version_num}R{release_num} | 'latest' ] */
        revisionStr: string;
        /** @description A path parameter that identifies a Rule */
        ruleId: string;
      };
    };
    responses: {
      /** @description RuleProjected response */
      200: {
        content: {
          "application/json": components["schemas"]["RuleProjected"];
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** Return the requester's user information */
  getUserObject: {
    responses: {
      /** @description User response */
      200: {
        content: {
          "application/json": components["schemas"]["UserProjected"];
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** Return a list of Users accessible to the requester */
  getUsers: {
    parameters: {
      query?: {
        elevate?: components["parameters"]["ElevateQuery"];
        projection?: components["parameters"]["UserProjectionQuery"];
        username?: components["parameters"]["UsernameQuery"];
        "username-match"?: components["parameters"]["UsernameMatchQuery"];
      };
    };
    responses: {
      /** @description UserProjected array response */
      200: {
        content: {
          "application/json": components["schemas"]["UserProjected"][];
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** Create a User */
  createUser: {
    parameters: {
      query?: {
        elevate?: components["parameters"]["ElevateQuery"];
        projection?: components["parameters"]["UserProjectionQuery"];
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UserCreateOrReplace"];
      };
    };
    responses: {
      /** @description UserProjected response */
      201: {
        content: {
          "application/json": components["schemas"]["UserProjected"];
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** Return a User */
  getUserByUserId: {
    parameters: {
      query?: {
        elevate?: components["parameters"]["ElevateQuery"];
        projection?: components["parameters"]["UserProjectionQuery"];
      };
      path: {
        userId: components["parameters"]["UserIdPath"];
      };
    };
    responses: {
      /** @description UserProjected response */
      200: {
        content: {
          "application/json": components["schemas"]["UserProjected"];
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** Set all properties of a User */
  replaceUser: {
    parameters: {
      query?: {
        elevate?: components["parameters"]["ElevateQuery"];
        projection?: components["parameters"]["UserProjectionQuery"];
      };
      path: {
        userId: components["parameters"]["UserIdPath"];
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UserCreateOrReplace"];
      };
    };
    responses: {
      /** @description UserProjected response */
      200: {
        content: {
          "application/json": components["schemas"]["UserProjected"];
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** Delete a User that has never accessed the system. */
  deleteUser: {
    parameters: {
      query?: {
        elevate?: components["parameters"]["ElevateQuery"];
        projection?: components["parameters"]["UserProjectionQuery"];
      };
      path: {
        userId: components["parameters"]["UserIdPath"];
      };
    };
    responses: {
      /** @description UserProjected response */
      200: {
        content: {
          "application/json": components["schemas"]["UserProjected"];
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** Merge provided properties with a User */
  updateUser: {
    parameters: {
      query?: {
        elevate?: components["parameters"]["ElevateQuery"];
        projection?: components["parameters"]["UserProjectionQuery"];
      };
      path: {
        userId: components["parameters"]["UserIdPath"];
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UserUpdate"];
      };
    };
    responses: {
      /** @description UserProjected response */
      200: {
        content: {
          "application/json": components["schemas"]["UserProjected"];
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
}
